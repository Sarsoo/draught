{"version":3,"sources":["webpack://draught/../pkg/draught_bg.js","webpack://draught/./index.js"],"names":["heap","Array","fill","undefined","getObject","idx","push","heap_next","length","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","Uint8Array","getStringFromWasm0","ptr","len","subarray","addHeapObject","obj","debugString","val","type","description","name","isArray","debug","i","builtInMatches","exec","toString","call","className","JSON","stringify","_","Error","message","stack","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","cachegetInt32Memory0","getInt32Memory0","Int32Array","isLikeNone","x","_assertClass","instance","klass","init_wasm","handleError","f","args","apply","this","e","Object","freeze","Move","Jump","Team","Black","White","Man","King","Empty","Occupied","Unplayable","Allowed","UnoccupiedSrc","OccupiedDest","OutOfBounds","WrongTeamSrc","IllegalTrajectory","NoJumpablePiece","JumpingSameTeam","Board","create","prototype","__destroy_into_raw","arg0","ret","Square","__wrap","square","ptr0","BrdIdx","row","col","from","to","ptr1","from_square_occupant","Piece","ptr2","team","jumpee","from_occ","width","height","current_turn","board","piece_rows","Game","first_turn","canvas_id","canvas_width","canvas_height","len0","value","Painter","canvas","strength","state","occupant","__wbindgen_object_drop_ref","dropObject","takeObject","__wbindgen_string_new","arg1","__wbg_new_59cb74e423758ede","__wbg_stack_558ba5917b466edd","__wbg_error_4bb6c2a97407129a","console","error","__wbg_instanceof_Window_11e25482011fc506","Window","__wbg_document_5aff8cd83ef968f5","document","__wbg_getElementById_b180ea4ada06a837","arg2","getElementById","__wbg_log_9a99fb1af846153b","log","__wbg_instanceof_CanvasRenderingContext2d_779e79c4121aa91b","CanvasRenderingContext2D","__wbg_setstrokeStyle_2939ee453716e462","strokeStyle","__wbg_setfillStyle_af790b5baf4d3210","fillStyle","__wbg_setlineWidth_3e6b1837ae38d099","lineWidth","__wbg_beginPath_2378575e37027ad3","beginPath","__wbg_fill_558339447ed6ad43","__wbg_stroke_c1e0313c58997dcf","stroke","__wbg_arc_fffd87d9113dce32","arg3","arg4","arg5","arc","arguments","__wbg_fillRect_46ffc8d2cef7e298","fillRect","__wbg_strokeRect_7ea34fad8a7f0fe2","strokeRect","__wbg_instanceof_HtmlCanvasElement_fd3cbbe3906d7792","HTMLCanvasElement","__wbg_setwidth_f3c88eb520ba8d47","__wbg_setheight_5a1abba41e35c42a","__wbg_getContext_813df131fcbd6e91","getContext","__wbg_newnoargs_9fdd8f3961dd1bee","Function","__wbg_call_ba36642bd901572b","__wbg_self_bb69a836a72ec6e9","self","__wbg_window_3304fc4b414c9693","window","__wbg_globalThis_e0d21cabc6630763","globalThis","__wbg_global_8463719227271676","g","global","__wbindgen_is_undefined","__wbindgen_object_clone_ref","__wbindgen_debug_string","__wbindgen_throw","GameState","current_state","painter","game","set_painter","draw","addEventListener","event","mousepos","evt","rect","getBoundingClientRect","clientX","left","y","clientY","top","getMousePos","cell_coord","make_move","process_canvas_click","Math","floor"],"mappings":"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","file":"10.bootstrap.js","sourcesContent":["import * as wasm from './draught_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n*/\nexport function init_wasm() {\n    wasm.init_wasm();\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nexport const MoveType = Object.freeze({ Move:0,\"0\":\"Move\",Jump:1,\"1\":\"Jump\", });\n/**\n*/\nexport const Team = Object.freeze({ Black:0,\"0\":\"Black\",White:1,\"1\":\"White\", });\n/**\n*/\nexport const Strength = Object.freeze({ Man:0,\"0\":\"Man\",King:1,\"1\":\"King\", });\n/**\n*/\nexport const SquareState = Object.freeze({ Empty:0,\"0\":\"Empty\",Occupied:1,\"1\":\"Occupied\",Unplayable:2,\"2\":\"Unplayable\", });\n/**\n*/\nexport const Moveable = Object.freeze({ Allowed:0,\"0\":\"Allowed\",UnoccupiedSrc:1,\"1\":\"UnoccupiedSrc\",OccupiedDest:2,\"2\":\"OccupiedDest\",OutOfBounds:3,\"3\":\"OutOfBounds\",Unplayable:4,\"4\":\"Unplayable\",WrongTeamSrc:5,\"5\":\"WrongTeamSrc\",IllegalTrajectory:6,\"6\":\"IllegalTrajectory\",NoJumpablePiece:7,\"7\":\"NoJumpablePiece\",JumpingSameTeam:8,\"8\":\"JumpingSameTeam\", });\n/**\n* Single state of a checkers board\n*/\nexport class Board {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Board.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_board_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get width() {\n        var ret = wasm.__wbg_get_board_width(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set width(arg0) {\n        wasm.__wbg_set_board_width(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get height() {\n        var ret = wasm.__wbg_get_board_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set height(arg0) {\n        wasm.__wbg_set_board_height(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get current_turn() {\n        var ret = wasm.__wbg_get_board_current_turn(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set current_turn(arg0) {\n        wasm.__wbg_set_board_current_turn(this.ptr, arg0);\n    }\n    /**\n    * Get a copy of a board square by 1D array index\n    * @param {number} idx\n    * @returns {Square}\n    */\n    cell(idx) {\n        var ret = wasm.board_cell(this.ptr, idx);\n        return Square.__wrap(ret);\n    }\n    /**\n    * Get a copy of a board square by 1D array index\n    * @param {number} idx\n    * @param {Square} square\n    */\n    set_cell(idx, square) {\n        _assertClass(square, Square);\n        var ptr0 = square.ptr;\n        square.ptr = 0;\n        wasm.board_set_cell(this.ptr, idx, ptr0);\n    }\n    /**\n    * Get a copy of a board square by 2D [`BrdIdx`] index\n    * @param {BrdIdx} idx\n    * @returns {Square}\n    */\n    grid_cell(idx) {\n        _assertClass(idx, BrdIdx);\n        var ptr0 = idx.ptr;\n        idx.ptr = 0;\n        var ret = wasm.board_grid_cell(this.ptr, ptr0);\n        return Square.__wrap(ret);\n    }\n    /**\n    * Transform a 2D row/column board index into a single 1D index for use with [`Board::cells`]\n    * @param {number} row\n    * @param {number} col\n    * @returns {number}\n    */\n    cell_index(row, col) {\n        var ret = wasm.board_cell_index(this.ptr, row, col);\n        return ret >>> 0;\n    }\n    /**\n    * Similar to [`Board::cell_index`] but with a [`BrdIdx`] instead of separate indices. Transform a 2D row/column board index into a single 1D index for use with [`Board::cells`]\n    * @param {BrdIdx} idx\n    * @returns {number}\n    */\n    cell_idx(idx) {\n        _assertClass(idx, BrdIdx);\n        var ptr0 = idx.ptr;\n        idx.ptr = 0;\n        var ret = wasm.board_cell_idx(this.ptr, ptr0);\n        return ret >>> 0;\n    }\n    /**\n    * Transform a 1D array index (for [`Board::cells`]) into a 2D game board index (by row/col)\n    * @param {number} idx\n    * @returns {BrdIdx}\n    */\n    board_index(idx) {\n        var ret = wasm.board_board_index(this.ptr, idx);\n        return BrdIdx.__wrap(ret);\n    }\n    /**\n    * Check whether a move given by source and destination indices is legal\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    * @returns {number}\n    */\n    can_move(from, to) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        var ret = wasm.board_can_move(this.ptr, ptr0, ptr1);\n        return ret >>> 0;\n    }\n    /**\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    * @param {Piece} from_square_occupant\n    * @returns {number}\n    */\n    validate_man_move(from, to, from_square_occupant) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        _assertClass(from_square_occupant, Piece);\n        var ptr2 = from_square_occupant.ptr;\n        from_square_occupant.ptr = 0;\n        var ret = wasm.board_validate_man_move(this.ptr, ptr0, ptr1, ptr2);\n        return ret >>> 0;\n    }\n    /**\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    * @param {Piece} from_square_occupant\n    * @returns {number}\n    */\n    validate_king_move(from, to, from_square_occupant) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        _assertClass(from_square_occupant, Piece);\n        var ptr2 = from_square_occupant.ptr;\n        from_square_occupant.ptr = 0;\n        var ret = wasm.board_validate_king_move(this.ptr, ptr0, ptr1, ptr2);\n        return ret >>> 0;\n    }\n    /**\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    * @returns {number}\n    */\n    jumpee_idx(from, to) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        var ret = wasm.board_jumpee_idx(this.ptr, ptr0, ptr1);\n        return ret >>> 0;\n    }\n    /**\n    * Get a pointer to the backing array of board squares, [`Board::cells`]\n    * @returns {number}\n    */\n    cells() {\n        var ret = wasm.board_cells(this.ptr);\n        return ret;\n    }\n    /**\n    * Get the number of board squares\n    * @returns {number}\n    */\n    num_cells() {\n        var ret = wasm.board_num_cells(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get the number of remaining pieces\n    * @returns {number}\n    */\n    num_pieces() {\n        var ret = wasm.board_num_pieces(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get the number of remaining pieces for a player\n    * @param {number} team\n    * @returns {number}\n    */\n    num_player(team) {\n        var ret = wasm.board_num_player(this.ptr, team);\n        return ret >>> 0;\n    }\n    /**\n    * Get the score value, Black - White pieces\n    * @returns {number}\n    */\n    score() {\n        var ret = wasm.board_score(this.ptr);\n        return ret;\n    }\n    /**\n    * Get the state of a board square by 1D array index\n    * @param {number} idx\n    * @returns {number}\n    */\n    cell_state(idx) {\n        var ret = wasm.board_cell_state(this.ptr, idx);\n        return ret >>> 0;\n    }\n    /**\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    * @returns {Board}\n    */\n    apply_move(from, to) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        var ret = wasm.board_apply_move(this.ptr, ptr0, ptr1);\n        return Board.__wrap(ret);\n    }\n    /**\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    * @returns {Board}\n    */\n    apply_jump(from, to) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        var ret = wasm.board_apply_jump(this.ptr, ptr0, ptr1);\n        return Board.__wrap(ret);\n    }\n    /**\n    * Unwrap the jumpee piece from the square and [`Board::check_jumpee_team`] with [`Moveable`] response\n    * @param {Square} jumpee\n    * @param {Piece} from_occ\n    * @returns {number}\n    */\n    static validate_jumpee(jumpee, from_occ) {\n        _assertClass(jumpee, Square);\n        var ptr0 = jumpee.ptr;\n        jumpee.ptr = 0;\n        _assertClass(from_occ, Piece);\n        var ptr1 = from_occ.ptr;\n        from_occ.ptr = 0;\n        var ret = wasm.board_validate_jumpee(ptr0, ptr1);\n        return ret >>> 0;\n    }\n    /**\n    * Check that the source piece and the jumpee are of opposing teams\n    * @param {Piece} from\n    * @param {Piece} jumpee\n    * @returns {boolean}\n    */\n    static check_jumpee_team(from, jumpee) {\n        _assertClass(from, Piece);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(jumpee, Piece);\n        var ptr1 = jumpee.ptr;\n        jumpee.ptr = 0;\n        var ret = wasm.board_check_jumpee_team(ptr0, ptr1);\n        return ret !== 0;\n    }\n    /**\n    * Initialise a game board without game pieces\n    * @param {number} width\n    * @param {number} height\n    * @param {number} current_turn\n    */\n    constructor(width, height, current_turn) {\n        var ret = wasm.board_new(width, height, current_turn);\n        return Board.__wrap(ret);\n    }\n    /**\n    * Reset the given board to a starting layout with 3 rows of opposing pieces\n    * @param {Board} board\n    * @param {number} piece_rows\n    * @returns {Board}\n    */\n    static init_game(board, piece_rows) {\n        _assertClass(board, Board);\n        var ptr0 = board.ptr;\n        board.ptr = 0;\n        var ret = wasm.board_init_game(ptr0, piece_rows);\n        return Board.__wrap(ret);\n    }\n}\n/**\n* Rank 2 tensor index to identify a board square by row and column\n*/\nexport class BrdIdx {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BrdIdx.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_brdidx_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get row() {\n        var ret = wasm.__wbg_get_brdidx_row(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set row(arg0) {\n        wasm.__wbg_set_brdidx_row(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get col() {\n        var ret = wasm.__wbg_get_brdidx_col(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set col(arg0) {\n        wasm.__wbg_set_brdidx_col(this.ptr, arg0);\n    }\n    /**\n    * @param {number} row\n    * @param {number} col\n    */\n    constructor(row, col) {\n        var ret = wasm.brdidx_from(row, col);\n        return BrdIdx.__wrap(ret);\n    }\n}\n/**\n* Root-level structure for managing the game as a collection of board states\n*/\nexport class Game {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Game.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_game_free(ptr);\n    }\n    /**\n    * Get pointer to current board's squares\n    * @returns {number}\n    */\n    current_board_cells() {\n        var ret = wasm.game_current_board_cells(this.ptr);\n        return ret;\n    }\n    /**\n    * Get pointer to current board's squares\n    * @returns {number}\n    */\n    current_board_len() {\n        var ret = wasm.game_current_board_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Current turn's team\n    * @returns {number}\n    */\n    current_turn() {\n        var ret = wasm.game_current_turn(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Attempt to make a move given a source and destination index\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    */\n    make_move(from, to) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        wasm.game_make_move(this.ptr, ptr0, ptr1);\n    }\n    /**\n    * Update board state with given move and push new board into current state\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    */\n    execute_move(from, to) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        wasm.game_execute_move(this.ptr, ptr0, ptr1);\n    }\n    /**\n    * Update board state with given jump move and push new board into current state\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    */\n    execute_jump(from, to) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        wasm.game_execute_jump(this.ptr, ptr0, ptr1);\n    }\n    /**\n    * Push current board into the previous turns and set given board to current\n    * @param {Board} board\n    */\n    push_new_board(board) {\n        _assertClass(board, Board);\n        var ptr0 = board.ptr;\n        board.ptr = 0;\n        wasm.game_push_new_board(this.ptr, ptr0);\n    }\n    /**\n    * Set current board to given\n    * @param {Board} board\n    */\n    set_current(board) {\n        _assertClass(board, Board);\n        var ptr0 = board.ptr;\n        board.ptr = 0;\n        wasm.game_set_current(this.ptr, ptr0);\n    }\n    /**\n    * @param {number} width\n    * @param {number} height\n    * @param {number} piece_rows\n    * @param {number} first_turn\n    */\n    constructor(width, height, piece_rows, first_turn) {\n        var ret = wasm.game_new(width, height, piece_rows, first_turn);\n        return Game.__wrap(ret);\n    }\n    /**\n    * @param {number} width\n    * @param {number} height\n    * @param {number} piece_rows\n    * @param {number} first_turn\n    * @param {string} canvas_id\n    * @param {number} canvas_width\n    * @param {number} canvas_height\n    * @returns {Game}\n    */\n    static new_with_canvas(width, height, piece_rows, first_turn, canvas_id, canvas_width, canvas_height) {\n        var ptr0 = passStringToWasm0(canvas_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.game_new_with_canvas(width, height, piece_rows, first_turn, ptr0, len0, canvas_width, canvas_height);\n        return Game.__wrap(ret);\n    }\n    /**\n    * @param {Painter} value\n    */\n    set_painter(value) {\n        _assertClass(value, Painter);\n        var ptr0 = value.ptr;\n        value.ptr = 0;\n        wasm.game_set_painter(this.ptr, ptr0);\n    }\n    /**\n    */\n    draw() {\n        wasm.game_draw(this.ptr);\n    }\n}\n/**\n* Used to paint boards onto HTML canvases\n*/\nexport class Painter {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Painter.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_painter_free(ptr);\n    }\n    /**\n    * Default constructor which queries for canvas by ID\n    * @param {number} width\n    * @param {number} height\n    * @param {string} canvas_id\n    */\n    constructor(width, height, canvas_id) {\n        var ptr0 = passStringToWasm0(canvas_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.painter_new(width, height, ptr0, len0);\n        return Painter.__wrap(ret);\n    }\n    /**\n    * Constructor with given canvas element\n    * @param {number} width\n    * @param {number} height\n    * @param {HTMLCanvasElement} canvas\n    * @returns {Painter}\n    */\n    static new_with_canvas(width, height, canvas) {\n        var ret = wasm.painter_new_with_canvas(width, height, addHeapObject(canvas));\n        return Painter.__wrap(ret);\n    }\n    /**\n    * Set new square outline colour value\n    * @param {any} value\n    */\n    set_square_outline(value) {\n        wasm.painter_set_square_outline(this.ptr, addHeapObject(value));\n    }\n    /**\n    * Set new line width for outlining squares\n    * @param {number} value\n    */\n    set_outline_width(value) {\n        wasm.painter_set_outline_width(this.ptr, value);\n    }\n    /**\n    * Set whether squares are outlined\n    * @param {boolean} value\n    */\n    set_draw_outline(value) {\n        wasm.painter_set_draw_outline(this.ptr, value);\n    }\n    /**\n    * Reset the canvas dimensions to the given width and height\n    */\n    reset_dimensions() {\n        wasm.painter_reset_dimensions(this.ptr);\n    }\n    /**\n    * Check whether given canvas dimensions divide evenly by given board dimenions\n    * @param {Board} board\n    * @returns {boolean}\n    */\n    validate_board_dim(board) {\n        _assertClass(board, Board);\n        var ret = wasm.painter_validate_board_dim(this.ptr, board.ptr);\n        return ret !== 0;\n    }\n    /**\n    * Draw a board onto the canvas\n    * @param {Board} board\n    */\n    draw(board) {\n        _assertClass(board, Board);\n        wasm.painter_draw(this.ptr, board.ptr);\n    }\n}\n/**\n* Game piece given by its team and strength (normal or kinged)\n*/\nexport class Piece {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Piece.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_piece_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get team() {\n        var ret = wasm.__wbg_get_piece_team(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set team(arg0) {\n        wasm.__wbg_set_piece_team(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get strength() {\n        var ret = wasm.__wbg_get_piece_strength(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set strength(arg0) {\n        wasm.__wbg_set_piece_strength(this.ptr, arg0);\n    }\n    /**\n    * @param {number} team\n    * @param {number} strength\n    */\n    constructor(team, strength) {\n        var ret = wasm.piece_new(team, strength);\n        return Piece.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Player {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_player_free(ptr);\n    }\n}\n/**\n* Board squares given by a state and a possible occupying game piece\n*/\nexport class Square {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Square.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_square_free(ptr);\n    }\n    /**\n    * Game piece if square is occupied\n    * @returns {Piece | undefined}\n    */\n    get occupant() {\n        var ret = wasm.__wbg_get_square_occupant(this.ptr);\n        return ret === 0 ? undefined : Piece.__wrap(ret);\n    }\n    /**\n    * Game piece if square is occupied\n    * @param {Piece | undefined} arg0\n    */\n    set occupant(arg0) {\n        let ptr0 = 0;\n        if (!isLikeNone(arg0)) {\n            _assertClass(arg0, Piece);\n            ptr0 = arg0.ptr;\n            arg0.ptr = 0;\n        }\n        wasm.__wbg_set_square_occupant(this.ptr, ptr0);\n    }\n    /**\n    * Description of whether the square is occupied or an unplayable, i.e. off-lattice square\n    * @returns {number}\n    */\n    get state() {\n        var ret = wasm.__wbg_get_square_state(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Description of whether the square is occupied or an unplayable, i.e. off-lattice square\n    * @param {number} arg0\n    */\n    set state(arg0) {\n        wasm.__wbg_set_square_state(this.ptr, arg0);\n    }\n    /**\n    * Standard constructor function to form square from state and occupant\n    * @param {number} state\n    * @param {Piece | undefined} occupant\n    */\n    constructor(state, occupant) {\n        let ptr0 = 0;\n        if (!isLikeNone(occupant)) {\n            _assertClass(occupant, Piece);\n            ptr0 = occupant.ptr;\n            occupant.ptr = 0;\n        }\n        var ret = wasm.square_new(state, ptr0);\n        return Square.__wrap(ret);\n    }\n    /**\n    * Helper function for a well-formed piece square by team and strength\n    * @param {number} team\n    * @param {number} strength\n    * @returns {Square}\n    */\n    static pc(team, strength) {\n        var ret = wasm.square_pc(team, strength);\n        return Square.__wrap(ret);\n    }\n    /**\n    * Helper function for a well-formed empty square\n    * @returns {Square}\n    */\n    static empty() {\n        var ret = wasm.square_empty();\n        return Square.__wrap(ret);\n    }\n    /**\n    * Helper function for a well-formed unplayable square\n    * @returns {Square}\n    */\n    static unplay() {\n        var ret = wasm.square_unplay();\n        return Square.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    var ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_59cb74e423758ede() {\n    var ret = new Error();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_stack_558ba5917b466edd(arg0, arg1) {\n    var ret = getObject(arg1).stack;\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbg_error_4bb6c2a97407129a(arg0, arg1) {\n    try {\n        console.error(getStringFromWasm0(arg0, arg1));\n    } finally {\n        wasm.__wbindgen_free(arg0, arg1);\n    }\n};\n\nexport function __wbg_instanceof_Window_11e25482011fc506(arg0) {\n    var ret = getObject(arg0) instanceof Window;\n    return ret;\n};\n\nexport function __wbg_document_5aff8cd83ef968f5(arg0) {\n    var ret = getObject(arg0).document;\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n};\n\nexport function __wbg_getElementById_b180ea4ada06a837(arg0, arg1, arg2) {\n    var ret = getObject(arg0).getElementById(getStringFromWasm0(arg1, arg2));\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n};\n\nexport function __wbg_log_9a99fb1af846153b(arg0) {\n    console.log(getObject(arg0));\n};\n\nexport function __wbg_instanceof_CanvasRenderingContext2d_779e79c4121aa91b(arg0) {\n    var ret = getObject(arg0) instanceof CanvasRenderingContext2D;\n    return ret;\n};\n\nexport function __wbg_setstrokeStyle_2939ee453716e462(arg0, arg1) {\n    getObject(arg0).strokeStyle = getObject(arg1);\n};\n\nexport function __wbg_setfillStyle_af790b5baf4d3210(arg0, arg1) {\n    getObject(arg0).fillStyle = getObject(arg1);\n};\n\nexport function __wbg_setlineWidth_3e6b1837ae38d099(arg0, arg1) {\n    getObject(arg0).lineWidth = arg1;\n};\n\nexport function __wbg_beginPath_2378575e37027ad3(arg0) {\n    getObject(arg0).beginPath();\n};\n\nexport function __wbg_fill_558339447ed6ad43(arg0) {\n    getObject(arg0).fill();\n};\n\nexport function __wbg_stroke_c1e0313c58997dcf(arg0) {\n    getObject(arg0).stroke();\n};\n\nexport function __wbg_arc_fffd87d9113dce32() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5) {\n    getObject(arg0).arc(arg1, arg2, arg3, arg4, arg5);\n}, arguments) };\n\nexport function __wbg_fillRect_46ffc8d2cef7e298(arg0, arg1, arg2, arg3, arg4) {\n    getObject(arg0).fillRect(arg1, arg2, arg3, arg4);\n};\n\nexport function __wbg_strokeRect_7ea34fad8a7f0fe2(arg0, arg1, arg2, arg3, arg4) {\n    getObject(arg0).strokeRect(arg1, arg2, arg3, arg4);\n};\n\nexport function __wbg_instanceof_HtmlCanvasElement_fd3cbbe3906d7792(arg0) {\n    var ret = getObject(arg0) instanceof HTMLCanvasElement;\n    return ret;\n};\n\nexport function __wbg_setwidth_f3c88eb520ba8d47(arg0, arg1) {\n    getObject(arg0).width = arg1 >>> 0;\n};\n\nexport function __wbg_setheight_5a1abba41e35c42a(arg0, arg1) {\n    getObject(arg0).height = arg1 >>> 0;\n};\n\nexport function __wbg_getContext_813df131fcbd6e91() { return handleError(function (arg0, arg1, arg2) {\n    var ret = getObject(arg0).getContext(getStringFromWasm0(arg1, arg2));\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_newnoargs_9fdd8f3961dd1bee(arg0, arg1) {\n    var ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_ba36642bd901572b() { return handleError(function (arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_self_bb69a836a72ec6e9() { return handleError(function () {\n    var ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_window_3304fc4b414c9693() { return handleError(function () {\n    var ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_globalThis_e0d21cabc6630763() { return handleError(function () {\n    var ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_global_8463719227271676() { return handleError(function () {\n    var ret = global.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_is_undefined(arg0) {\n    var ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nexport function __wbindgen_object_clone_ref(arg0) {\n    var ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_debug_string(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n","import { Game, Board, BrdIdx, Painter, Team, init_wasm } from \"draught\";\nimport { memory } from \"draught/draught_bg.wasm\";\n\n///////////////////\n//    CONSTS\n///////////////////\n\nconst CANVAS_WIDTH = 480;\nconst CANVAS_HEIGHT = 480;\n\nconst BOARD_WIDTH = 8;\nconst BOARD_HEIGHT = 8;\n\nconst PIECE_ROWS = 3;\n\nconst GameState = {\n    HUMAN_TURN: {\n        THINKING: \"human_turn.thinking\",\n        FROM_SELECTED: \"human_turn.from_selected\"\n    },\n    AI_TURN: \"ai_turn\"\n}\n\n//////////////////\n//  GAME STUFF\n//////////////////\n\ninit_wasm();\n\n// let board = new Board(BOARD_WIDTH, BOARD_HEIGHT, Team.Black);\n\nlet current_state = GameState.HUMAN_TURN.THINKING;\nlet painter = new Painter(CANVAS_WIDTH, CANVAS_HEIGHT, \"game-canvas\");\n// painter.draw(board);\n\nlet from = null;\nlet to = null;\n\nlet game = new Game(BOARD_WIDTH, BOARD_HEIGHT, PIECE_ROWS, Team.Black);\ngame.set_painter(painter);\ngame.draw();\n\n/////////////////\n//   CANVAS\n/////////////////\n\nconst canvas = document.getElementById(\"game-canvas\");\ncanvas.addEventListener(\"click\", (event) => {\n    var mousepos = getMousePos(canvas, event);\n    // console.log(mousepos);\n    var cell = new BrdIdx(\n        Math.floor((mousepos.y / CANVAS_HEIGHT) * BOARD_HEIGHT),\n        Math.floor((mousepos.x / CANVAS_WIDTH) * BOARD_WIDTH),\n    );\n    // console.log(cell);\n    process_canvas_click(cell);\n})\n\n////////////////\n//   FUNCS\n////////////////\n\nfunction start_game() {\n    game = new Game(BOARD_WIDTH, BOARD_HEIGHT, PIECE_ROWS, Team.Black);\n    game.set_painter(painter);\n    game.draw();\n\n    current_state = GameState.HUMAN_TURN.THINKING;\n}\n\nfunction process_canvas_click(cell_coord) {\n    switch(current_state) {\n        case GameState.HUMAN_TURN.THINKING:\n            console.log(\"Your turn, first piece picked\");\n\n            from = cell_coord;\n            current_state = GameState.HUMAN_TURN.FROM_SELECTED; \n            \n            break;\n        case GameState.HUMAN_TURN.FROM_SELECTED:\n            console.log(\"Your turn, first piece already picked, picking second\");\n\n            to = cell_coord;\n            game.make_move(from, to);\n            game.draw();\n\n            current_state = GameState.HUMAN_TURN.THINKING;\n            \n            break;\n        case GameState.AI_TURN:\n            console.log(\"It's the AI's turn!\");\n            break;\n    }\n}\n\nfunction getMousePos(canvas, evt) {\n    var rect = canvas.getBoundingClientRect();\n    return {\n        x: evt.clientX - rect.left,\n        y: evt.clientY - rect.top\n    };\n}\n\n"],"sourceRoot":""}