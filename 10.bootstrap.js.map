{"version":3,"sources":["webpack://draught/../pkg/draught_bg.js","webpack://draught/./index.js"],"names":["heap","Array","fill","undefined","getObject","idx","push","heap_next","length","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","Uint8Array","getStringFromWasm0","ptr","len","subarray","addHeapObject","obj","debugString","val","type","description","name","isArray","debug","i","builtInMatches","exec","toString","call","className","JSON","stringify","_","Error","message","stack","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","cachegetInt32Memory0","getInt32Memory0","Int32Array","isLikeNone","x","_assertClass","instance","klass","init_wasm","handleError","f","args","apply","this","e","Object","freeze","Move","Jump","Team","Black","White","SquareState","Man","King","Empty","Occupied","Unplayable","Moveable","Allowed","UnoccupiedSrc","OccupiedDest","OutOfBounds","WrongTeamSrc","IllegalTrajectory","NoJumpablePiece","JumpingSameTeam","Board","create","prototype","__destroy_into_raw","arg0","ret","Square","__wrap","square","ptr0","BrdIdx","row","col","from","to","ptr1","from_square_occupant","Piece","ptr2","team","jumpee","from_occ","width","height","current_turn","board","piece_rows","other","Game","search_depth","new_chance","first_turn","canvas_id","canvas_width","canvas_height","len0","value","Painter","canvas","strength","state","occupant","__wbindgen_object_drop_ref","dropObject","takeObject","__wbindgen_string_new","arg1","__wbg_new_59cb74e423758ede","__wbg_stack_558ba5917b466edd","__wbg_error_4bb6c2a97407129a","console","error","__wbg_self_86b4b13392c7af56","self","arguments","__wbg_require_f5521a5b85ad2542","arg2","__wbg_crypto_b8c92eaac23d0d80","crypto","__wbg_msCrypto_9ad6677321a08dd8","msCrypto","__wbindgen_is_undefined","__wbg_getRandomValues_dd27e6b0652b3236","getRandomValues","__wbg_getRandomValues_e57c9b75ddead065","__wbg_randomFillSync_d2ba53160aec6aba","randomFillSync","__wbg_static_accessor_MODULE_452b4680e8614c81","__wbg_instanceof_Window_11e25482011fc506","Window","__wbg_document_5aff8cd83ef968f5","document","__wbg_getElementById_b180ea4ada06a837","getElementById","__wbg_error_d95afd6217cfd219","__wbg_log_9a99fb1af846153b","log","__wbg_instanceof_CanvasRenderingContext2d_779e79c4121aa91b","CanvasRenderingContext2D","__wbg_setstrokeStyle_2939ee453716e462","strokeStyle","__wbg_setfillStyle_af790b5baf4d3210","fillStyle","__wbg_setlineWidth_3e6b1837ae38d099","lineWidth","__wbg_beginPath_2378575e37027ad3","beginPath","__wbg_fill_558339447ed6ad43","__wbg_stroke_c1e0313c58997dcf","stroke","__wbg_arc_fffd87d9113dce32","arg3","arg4","arg5","arc","__wbg_fillRect_46ffc8d2cef7e298","fillRect","__wbg_strokeRect_7ea34fad8a7f0fe2","strokeRect","__wbg_instanceof_HtmlCanvasElement_fd3cbbe3906d7792","HTMLCanvasElement","__wbg_setwidth_f3c88eb520ba8d47","__wbg_setheight_5a1abba41e35c42a","__wbg_getContext_813df131fcbd6e91","getContext","__wbg_newnoargs_9fdd8f3961dd1bee","Function","__wbg_call_ba36642bd901572b","__wbg_self_bb69a836a72ec6e9","__wbg_window_3304fc4b414c9693","window","__wbg_globalThis_e0d21cabc6630763","globalThis","__wbg_global_8463719227271676","g","global","__wbg_buffer_9e184d6f785de5ed","__wbg_new_e8101319e4cf95fc","__wbg_set_e8ae7b27314e8b98","__wbg_length_2d56cb37075fcfb1","__wbg_newwithlength_a8d1dbcbe703a5c6","__wbg_subarray_901ede8318da52a6","__wbindgen_object_clone_ref","__wbindgen_debug_string","__wbindgen_throw","__wbindgen_memory","BOARD_WIDTH","BOARD_HEIGHT","PIECE_ROWS","SEARCH_DEPTH","PERFECT_CHANCE","GameState","statusAlert","teamText","nodeCountText","winningText","onclick","start_game","wonTimeout","statusTimeout","setStatus","txt","alertType","hide","clearInterval","innerText","hidden","setTimeout","current_state","game","painter","clicks","set_painter","draw","updateTeamText","updateWinningText","winning","addEventListener","event","mousepos","evt","rect","getBoundingClientRect","clientX","left","y","clientY","top","getMousePos","cell_coord","current_cell_state","set_selected","eq","make_move","aiCheckBox","checked","has_won","ai_move","last_node_count","toLocaleString","clear_selected","setInterval","checkWon","process_canvas_click","Math","floor","clientHeight","clientWidth","widthBox","onchange","parseInt","heightBox","pieceRowsBox","max","aiSearchDepthBox","set_search_depth","aiPerfectChance","set_perfect_chance"],"mappings":"0sBAEA,MAAMA,EAAO,IAAIC,MAAM,IAAIC,UAAKC,GAIhC,SAASC,EAAUC,GAAO,OAAOL,EAAKK,GAFtCL,EAAKM,UAAKH,EAAW,MAAM,GAAM,GAIjC,IAAII,EAAYP,EAAKQ,OAgBrB,IAAIC,EAAoB,IAFoB,oBAAhBC,aAA8B,EAAIC,EAAOC,SAAS,QAAQF,YAAcA,aAE3D,QAAS,CAAEG,WAAW,EAAMC,OAAO,IAE5EL,EAAkBM,SAElB,IAAIC,EAAuB,KAC3B,SAASC,IAIL,OAH6B,OAAzBD,GAAiCA,EAAqBE,SAAW,kBACjEF,EAAuB,IAAIG,WAAW,kBAEnCH,EAGX,SAASI,EAAmBC,EAAKC,GAC7B,OAAOb,EAAkBM,OAAOE,IAAkBM,SAASF,EAAKA,EAAMC,IAG1E,SAASE,EAAcC,GACflB,IAAcP,EAAKQ,QAAQR,EAAKM,KAAKN,EAAKQ,OAAS,GACvD,MAAMH,EAAME,EAIZ,OAHAA,EAAYP,EAAKK,GAEjBL,EAAKK,GAAOoB,EACLpB,EAGX,SAASqB,EAAYC,GAEjB,MAAMC,SAAcD,EACpB,GAAY,UAARC,GAA4B,WAARA,GAA4B,MAAPD,EACzC,MAAQ,GAAGA,IAEf,GAAY,UAARC,EACA,MAAO,IAAID,KAEf,GAAY,UAARC,EAAkB,CAClB,MAAMC,EAAcF,EAAIE,YACxB,OAAmB,MAAfA,EACO,SAEA,UAAUA,KAGzB,GAAY,YAARD,EAAoB,CACpB,MAAME,EAAOH,EAAIG,KACjB,MAAmB,iBAARA,GAAoBA,EAAKtB,OAAS,EAClC,YAAYsB,KAEZ,WAIf,GAAI7B,MAAM8B,QAAQJ,GAAM,CACpB,MAAMnB,EAASmB,EAAInB,OACnB,IAAIwB,EAAQ,IACRxB,EAAS,IACTwB,GAASN,EAAYC,EAAI,KAE7B,IAAI,IAAIM,EAAI,EAAGA,EAAIzB,EAAQyB,IACvBD,GAAS,KAAON,EAAYC,EAAIM,IAGpC,OADAD,GAAS,IACFA,EAGX,MAAME,EAAiB,sBAAsBC,KAAKC,SAASC,KAAKV,IAChE,IAAIW,EACJ,KAAIJ,EAAe1B,OAAS,GAIxB,OAAO4B,SAASC,KAAKV,GAEzB,GALIW,EAAYJ,EAAe,GAKd,UAAbI,EAIA,IACI,MAAO,UAAYC,KAAKC,UAAUb,GAAO,IAC3C,MAAOc,GACL,MAAO,SAIf,OAAId,aAAee,MACR,GAAGf,EAAIG,SAASH,EAAIgB,YAAYhB,EAAIiB,QAGxCN,EAGX,IAAIO,EAAkB,EAIlBC,EAAoB,IAFoB,oBAAhBC,aAA8B,EAAIpC,EAAOC,SAAS,QAAQmC,YAAcA,aAE3D,SAEzC,MAAMC,EAAwD,mBAAjCF,EAAkBG,WACzC,SAAUC,EAAKC,GACjB,OAAOL,EAAkBG,WAAWC,EAAKC,IAEvC,SAAUD,EAAKC,GACjB,MAAMC,EAAMN,EAAkBO,OAAOH,GAErC,OADAC,EAAKG,IAAIF,GACF,CACHG,KAAML,EAAI1C,OACVgD,QAASJ,EAAI5C,SAIrB,SAASiD,EAAkBP,EAAKQ,EAAQC,GAEpC,QAAgBxD,IAAZwD,EAAuB,CACvB,MAAMP,EAAMN,EAAkBO,OAAOH,GAC/B7B,EAAMqC,EAAON,EAAI5C,QAGvB,OAFAS,IAAkBM,SAASF,EAAKA,EAAM+B,EAAI5C,QAAQ8C,IAAIF,GACtDP,EAAkBO,EAAI5C,OACfa,EAGX,IAAIC,EAAM4B,EAAI1C,OACVa,EAAMqC,EAAOpC,GAEjB,MAAMsC,EAAM3C,IAEZ,IAAI4C,EAAS,EAEb,KAAOA,EAASvC,EAAKuC,IAAU,CAC3B,MAAMC,EAAOZ,EAAIa,WAAWF,GAC5B,GAAIC,EAAO,IAAM,MACjBF,EAAIvC,EAAMwC,GAAUC,EAGxB,GAAID,IAAWvC,EAAK,CACD,IAAXuC,IACAX,EAAMA,EAAIc,MAAMH,IAEpBxC,EAAMsC,EAAQtC,EAAKC,EAAKA,EAAMuC,EAAsB,EAAbX,EAAI1C,QAC3C,MAAM2C,EAAOlC,IAAkBM,SAASF,EAAMwC,EAAQxC,EAAMC,GAG5DuC,GAFYb,EAAaE,EAAKC,GAEhBK,QAIlB,OADAX,EAAkBgB,EACXxC,EAGX,IAAI4C,EAAuB,KAC3B,SAASC,IAIL,OAH6B,OAAzBD,GAAiCA,EAAqB/C,SAAW,kBACjE+C,EAAuB,IAAIE,WAAW,kBAEnCF,EAGX,SAASG,EAAWC,GAChB,OAAOA,QAGX,SAASC,EAAaC,EAAUC,GAC5B,KAAMD,aAAoBC,GACtB,MAAM,IAAI9B,MAAM,wBAAwB8B,EAAM1C,QAElD,OAAOyC,EAASlD,IAIb,SAASoD,IACZ,cAGJ,SAASC,EAAYC,EAAGC,GACpB,IACI,OAAOD,EAAEE,MAAMC,KAAMF,GACvB,MAAOG,GACL,uBAA0BvD,EAAcuD,KAUxBC,OAAOC,OAAO,CAAEC,KAAK,EAAE,EAAI,OAAOC,KAAK,EAAE,EAAI,SAA9D,MAIMC,EAAOJ,OAAOC,OAAO,CAAEI,MAAM,EAAE,EAAI,QAAQC,MAAM,EAAE,EAAI,UAQvDC,GAJWP,OAAOC,OAAO,CAAEO,IAAI,EAAE,EAAI,MAAMC,KAAK,EAAE,EAAI,SAIxCT,OAAOC,OAAO,CAAES,MAAM,EAAE,EAAI,QAAQC,SAAS,EAAE,EAAI,WAAWC,WAAW,EAAE,EAAI,gBAI7FC,EAAWb,OAAOC,OAAO,CAAEa,QAAQ,EAAE,EAAI,UAAUC,cAAc,EAAE,EAAI,gBAAgBC,aAAa,EAAE,EAAI,eAAeC,YAAY,EAAE,EAAI,cAAcL,WAAW,EAAE,EAAI,aAAaM,aAAa,EAAE,EAAI,eAAeC,kBAAkB,EAAE,EAAI,oBAAoBC,gBAAgB,EAAE,EAAI,kBAAkBC,gBAAgB,EAAE,EAAI,oBAIzU,MAAMC,EAET,cAAcjF,GACV,MAAMI,EAAMuD,OAAOuB,OAAOD,EAAME,WAGhC,OAFA/E,EAAIJ,IAAMA,EAEHI,EAGX,qBACI,MAAMJ,EAAMyD,KAAKzD,IAGjB,OAFAyD,KAAKzD,IAAM,EAEJA,EAGX,OACI,MAAMA,EAAMyD,KAAK2B,qBACjB,mBAAsBpF,GAK1B,YAEI,OADU,wBAA2ByD,KAAKzD,OAC3B,EAKnB,UAAUqF,GACN,wBAA2B5B,KAAKzD,IAAKqF,GAKzC,aAEI,OADU,yBAA4B5B,KAAKzD,OAC5B,EAKnB,WAAWqF,GACP,yBAA4B5B,KAAKzD,IAAKqF,GAK1C,mBAEI,OADU,+BAAkC5B,KAAKzD,OAClC,EAKnB,iBAAiBqF,GACb,+BAAkC5B,KAAKzD,IAAKqF,GAOhD,KAAKrG,GACD,IAAIsG,EAAM,aAAgB7B,KAAKzD,IAAKhB,GACpC,OAAOuG,EAAOC,OAAOF,GAOzB,SAAStG,EAAKyG,GACVxC,EAAawC,EAAQF,GACrB,IAAIG,EAAOD,EAAOzF,IAClByF,EAAOzF,IAAM,EACb,iBAAoByD,KAAKzD,IAAKhB,EAAK0G,GAOvC,UAAU1G,GACNiE,EAAajE,EAAK2G,GAClB,IAAID,EAAO1G,EAAIgB,IACfhB,EAAIgB,IAAM,EACV,IAAIsF,EAAM,kBAAqB7B,KAAKzD,IAAK0F,GACzC,OAAOH,EAAOC,OAAOF,GAQzB,WAAWM,EAAKC,GAEZ,OADU,mBAAsBpC,KAAKzD,IAAK4F,EAAKC,KAChC,EAOnB,SAAS7G,GACLiE,EAAajE,EAAK2G,GAClB,IAAID,EAAO1G,EAAIgB,IAGf,OAFAhB,EAAIgB,IAAM,EACA,iBAAoByD,KAAKzD,IAAK0F,KACzB,EAOnB,YAAY1G,GACR,IAAIsG,EAAM,oBAAuB7B,KAAKzD,IAAKhB,GAC3C,OAAO2G,EAAOH,OAAOF,GAQzB,SAASQ,EAAMC,GACX9C,EAAa6C,EAAMH,GACnB,IAAID,EAAOI,EAAK9F,IAChB8F,EAAK9F,IAAM,EACXiD,EAAa8C,EAAIJ,GACjB,IAAIK,EAAOD,EAAG/F,IAGd,OAFA+F,EAAG/F,IAAM,EACC,iBAAoByD,KAAKzD,IAAK0F,EAAMM,KAC/B,EASnB,kBAAkBF,EAAMC,EAAIE,GACxBhD,EAAa6C,EAAMH,GACnB,IAAID,EAAOI,EAAK9F,IAChB8F,EAAK9F,IAAM,EACXiD,EAAa8C,EAAIJ,GACjB,IAAIK,EAAOD,EAAG/F,IACd+F,EAAG/F,IAAM,EACTiD,EAAagD,EAAsBC,GACnC,IAAIC,EAAOF,EAAqBjG,IAGhC,OAFAiG,EAAqBjG,IAAM,EACjB,0BAA6ByD,KAAKzD,IAAK0F,EAAMM,EAAMG,KAC9C,EASnB,mBAAmBL,EAAMC,EAAIE,GACzBhD,EAAa6C,EAAMH,GACnB,IAAID,EAAOI,EAAK9F,IAChB8F,EAAK9F,IAAM,EACXiD,EAAa8C,EAAIJ,GACjB,IAAIK,EAAOD,EAAG/F,IACd+F,EAAG/F,IAAM,EACTiD,EAAagD,EAAsBC,GACnC,IAAIC,EAAOF,EAAqBjG,IAGhC,OAFAiG,EAAqBjG,IAAM,EACjB,2BAA8ByD,KAAKzD,IAAK0F,EAAMM,EAAMG,KAC/C,EAQnB,WAAWL,EAAMC,GACb9C,EAAa6C,EAAMH,GACnB,IAAID,EAAOI,EAAK9F,IAChB8F,EAAK9F,IAAM,EACXiD,EAAa8C,EAAIJ,GACjB,IAAIK,EAAOD,EAAG/F,IAGd,OAFA+F,EAAG/F,IAAM,EACC,mBAAsByD,KAAKzD,IAAK0F,EAAMM,KACjC,EAMnB,QAEI,OADU,cAAiBvC,KAAKzD,KAOpC,YAEI,OADU,kBAAqByD,KAAKzD,OACrB,EAMnB,aAEI,OADU,mBAAsByD,KAAKzD,OACtB,EAOnB,WAAWoG,GAEP,OADU,mBAAsB3C,KAAKzD,IAAKoG,KAC3B,EAMnB,QAEI,OADU,cAAiB3C,KAAKzD,KAQpC,WAAWhB,GAEP,OADU,mBAAsByE,KAAKzD,IAAKhB,KAC3B,EAQnB,WAAW8G,EAAMC,GACb9C,EAAa6C,EAAMH,GACnB,IAAID,EAAOI,EAAK9F,IAChB8F,EAAK9F,IAAM,EACXiD,EAAa8C,EAAIJ,GACjB,IAAIK,EAAOD,EAAG/F,IACd+F,EAAG/F,IAAM,EACT,IAAIsF,EAAM,mBAAsB7B,KAAKzD,IAAK0F,EAAMM,GAChD,OAAOf,EAAMO,OAAOF,GAQxB,WAAWQ,EAAMC,GACb9C,EAAa6C,EAAMH,GACnB,IAAID,EAAOI,EAAK9F,IAChB8F,EAAK9F,IAAM,EACXiD,EAAa8C,EAAIJ,GACjB,IAAIK,EAAOD,EAAG/F,IACd+F,EAAG/F,IAAM,EACT,IAAIsF,EAAM,mBAAsB7B,KAAKzD,IAAK0F,EAAMM,GAChD,OAAOf,EAAMO,OAAOF,GAMxB,eAEI,OADU,qBAAwB7B,KAAKzD,OACxB,EAQnB,uBAAuBqG,EAAQC,GAC3BrD,EAAaoD,EAAQd,GACrB,IAAIG,EAAOW,EAAOrG,IAClBqG,EAAOrG,IAAM,EACbiD,EAAaqD,EAAUJ,GACvB,IAAIF,EAAOM,EAAStG,IAGpB,OAFAsG,EAAStG,IAAM,EACL,wBAA2B0F,EAAMM,KAC5B,EAQnB,yBAAyBF,EAAMO,GAC3BpD,EAAa6C,EAAMI,GACnB,IAAIR,EAAOI,EAAK9F,IAChB8F,EAAK9F,IAAM,EACXiD,EAAaoD,EAAQH,GACrB,IAAIF,EAAOK,EAAOrG,IAGlB,OAFAqG,EAAOrG,IAAM,EAEE,IADL,0BAA6B0F,EAAMM,GASjD,YAAYO,EAAOC,EAAQC,GACvB,IAAInB,EAAM,YAAeiB,EAAOC,EAAQC,GACxC,OAAOxB,EAAMO,OAAOF,GAQxB,iBAAiBoB,EAAOC,GACpB1D,EAAayD,EAAOzB,GACpB,IAAIS,EAAOgB,EAAM1G,IACjB0G,EAAM1G,IAAM,EACZ,IAAIsF,EAAM,kBAAqBI,EAAMiB,GACrC,OAAO1B,EAAMO,OAAOF,IAMrB,MAAMK,EAET,cAAc3F,GACV,MAAMI,EAAMuD,OAAOuB,OAAOS,EAAOR,WAGjC,OAFA/E,EAAIJ,IAAMA,EAEHI,EAGX,qBACI,MAAMJ,EAAMyD,KAAKzD,IAGjB,OAFAyD,KAAKzD,IAAM,EAEJA,EAGX,OACI,MAAMA,EAAMyD,KAAK2B,qBACjB,oBAAuBpF,GAK3B,UAEI,OADU,uBAA0ByD,KAAKzD,OAC1B,EAKnB,QAAQqF,GACJ,uBAA0B5B,KAAKzD,IAAKqF,GAKxC,UAEI,OADU,uBAA0B5B,KAAKzD,OAC1B,EAKnB,QAAQqF,GACJ,uBAA0B5B,KAAKzD,IAAKqF,GAMxC,YAAYO,EAAKC,GACb,IAAIP,EAAM,cAAiBM,EAAKC,GAChC,OAAOF,EAAOH,OAAOF,GAMzB,GAAGsB,GAGC,OAFA3D,EAAa2D,EAAOjB,GAEL,IADL,YAAelC,KAAKzD,IAAK4G,EAAM5G,MAO1C,MAAM6G,EAET,cAAc7G,GACV,MAAMI,EAAMuD,OAAOuB,OAAO2B,EAAK1B,WAG/B,OAFA/E,EAAIJ,IAAMA,EAEHI,EAGX,qBACI,MAAMJ,EAAMyD,KAAKzD,IAGjB,OAFAyD,KAAKzD,IAAM,EAEJA,EAGX,OACI,MAAMA,EAAMyD,KAAK2B,qBACjB,kBAAqBpF,GAKzB,sBAEI,OADU,iCAAoCyD,KAAKzD,OACpC,EAKnB,oBAAoBqF,GAChB,iCAAoC5B,KAAKzD,IAAKqF,GAKlD,qBAEI,OADU,gCAAmC5B,KAAKzD,KAMtD,mBAAmBqF,GACf,gCAAmC5B,KAAKzD,IAAKqF,GAMjD,sBAEI,OADU,2BAA8B5B,KAAKzD,KAOjD,oBAEI,OADU,yBAA4ByD,KAAKzD,OAC5B,EAMnB,eAEI,OADU,oBAAuByD,KAAKzD,OACvB,EAMnB,QAEI,OADU,aAAgByD,KAAKzD,KAOnC,UACI,IAAIsF,EAAM,eAAkB7B,KAAKzD,KACjC,OAAe,IAARsF,OAAYxG,EAAYwG,EAMnC,UACI,IAAIA,EAAM,eAAkB7B,KAAKzD,KACjC,OAAe,IAARsF,OAAYxG,EAAYwG,EAOnC,mBAAmBtG,GACfiE,EAAajE,EAAK2G,GAClB,IAAIL,EAAM,0BAA6B7B,KAAKzD,IAAKhB,EAAIgB,KACrD,OAAOuF,EAAOC,OAAOF,GAMzB,iBAAiBwB,GACb,wBAA2BrD,KAAKzD,IAAK8G,GAOzC,aAAa9H,GACTiE,EAAajE,EAAK2G,GAClB,oBAAuBlC,KAAKzD,IAAKhB,EAAIgB,KAMzC,mBAAmB+G,GACf,0BAA6BtD,KAAKzD,IAAK+G,GAK3C,iBACI,sBAAyBtD,KAAKzD,KAQlC,UAAU8F,EAAMC,GACZ9C,EAAa6C,EAAMH,GACnB,IAAID,EAAOI,EAAK9F,IAChB8F,EAAK9F,IAAM,EACXiD,EAAa8C,EAAIJ,GACjB,IAAIK,EAAOD,EAAG/F,IAGd,OAFA+F,EAAG/F,IAAM,EACC,iBAAoByD,KAAKzD,IAAK0F,EAAMM,KAC/B,EAOnB,aAAaF,EAAMC,GACf9C,EAAa6C,EAAMH,GACnB,IAAID,EAAOI,EAAK9F,IAChB8F,EAAK9F,IAAM,EACXiD,EAAa8C,EAAIJ,GACjB,IAAIK,EAAOD,EAAG/F,IACd+F,EAAG/F,IAAM,EACT,oBAAuByD,KAAKzD,IAAK0F,EAAMM,GAO3C,aAAaF,EAAMC,GACf9C,EAAa6C,EAAMH,GACnB,IAAID,EAAOI,EAAK9F,IAChB8F,EAAK9F,IAAM,EACXiD,EAAa8C,EAAIJ,GACjB,IAAIK,EAAOD,EAAG/F,IACd+F,EAAG/F,IAAM,EACT,oBAAuByD,KAAKzD,IAAK0F,EAAMM,GAM3C,eAAeU,GACXzD,EAAayD,EAAOzB,GACpB,IAAIS,EAAOgB,EAAM1G,IACjB0G,EAAM1G,IAAM,EACZ,sBAAyByD,KAAKzD,IAAK0F,GAMvC,YAAYgB,GACRzD,EAAayD,EAAOzB,GACpB,IAAIS,EAAOgB,EAAM1G,IACjB0G,EAAM1G,IAAM,EACZ,mBAAsByD,KAAKzD,IAAK0F,GAUpC,YAAYa,EAAOC,EAAQG,EAAYK,EAAYF,GAC/C,IAAIxB,EAAM,WAAciB,EAAOC,EAAQG,EAAYK,EAAYF,GAC/D,OAAOD,EAAKrB,OAAOF,GAcvB,uBAAuBiB,EAAOC,EAAQG,EAAYK,EAAYF,EAAcG,EAAWC,EAAcC,GACjG,IAAIzB,EAAOtD,EAAkB6E,EAAW,oBAAwB,sBAC5DG,EAAO5F,EACP8D,EAAM,uBAA0BiB,EAAOC,EAAQG,EAAYK,EAAYF,EAAcpB,EAAM0B,EAAMF,EAAcC,GACnH,OAAON,EAAKrB,OAAOF,GAMvB,YAAY+B,GACRpE,EAAaoE,EAAOC,GACpB,IAAI5B,EAAO2B,EAAMrH,IACjBqH,EAAMrH,IAAM,EACZ,mBAAsByD,KAAKzD,IAAK0F,GAKpC,OACI,YAAejC,KAAKzD,KAKxB,UACI,eAAkByD,KAAKzD,MAMxB,MAAMsH,EAET,cAActH,GACV,MAAMI,EAAMuD,OAAOuB,OAAOoC,EAAQnC,WAGlC,OAFA/E,EAAIJ,IAAMA,EAEHI,EAGX,qBACI,MAAMJ,EAAMyD,KAAKzD,IAGjB,OAFAyD,KAAKzD,IAAM,EAEJA,EAGX,OACI,MAAMA,EAAMyD,KAAK2B,qBACjB,qBAAwBpF,GAQ5B,YAAYuG,EAAOC,EAAQS,GACvB,IAAIvB,EAAOtD,EAAkB6E,EAAW,oBAAwB,sBAC5DG,EAAO5F,EACP8D,EAAM,cAAiBiB,EAAOC,EAAQd,EAAM0B,GAChD,OAAOE,EAAQ9B,OAAOF,GAS1B,uBAAuBiB,EAAOC,EAAQe,GAClC,IAAIjC,EAAM,0BAA6BiB,EAAOC,EAAQrG,EAAcoH,IACpE,OAAOD,EAAQ9B,OAAOF,GAM1B,mBAAmB+B,GACf,6BAAgC5D,KAAKzD,IAAKG,EAAckH,IAM5D,kBAAkBA,GACd,4BAA+B5D,KAAKzD,IAAKqH,GAM7C,iBAAiBA,GACb,2BAA8B5D,KAAKzD,IAAKqH,GAK5C,mBACI,2BAA8B5D,KAAKzD,KAOvC,mBAAmB0G,GAGf,OAFAzD,EAAayD,EAAOzB,GAEL,IADL,6BAAgCxB,KAAKzD,IAAK0G,EAAM1G,KAO9D,KAAK0G,GACDzD,EAAayD,EAAOzB,GACpB,eAAkBxB,KAAKzD,IAAK0G,EAAM1G,MAMnC,MAAMkG,EAET,cAAclG,GACV,MAAMI,EAAMuD,OAAOuB,OAAOgB,EAAMf,WAGhC,OAFA/E,EAAIJ,IAAMA,EAEHI,EAGX,qBACI,MAAMJ,EAAMyD,KAAKzD,IAGjB,OAFAyD,KAAKzD,IAAM,EAEJA,EAGX,OACI,MAAMA,EAAMyD,KAAK2B,qBACjB,mBAAsBpF,GAK1B,WAEI,OADU,uBAA0ByD,KAAKzD,OAC1B,EAKnB,SAASqF,GACL,uBAA0B5B,KAAKzD,IAAKqF,GAKxC,eAEI,OADU,2BAA8B5B,KAAKzD,OAC9B,EAKnB,aAAaqF,GACT,2BAA8B5B,KAAKzD,IAAKqF,GAM5C,YAAYe,EAAMoB,GACd,IAAIlC,EAAM,YAAec,EAAMoB,GAC/B,OAAOtB,EAAMV,OAAOF,IAMrB,MAAMC,EAET,cAAcvF,GACV,MAAMI,EAAMuD,OAAOuB,OAAOK,EAAOJ,WAGjC,OAFA/E,EAAIJ,IAAMA,EAEHI,EAGX,qBACI,MAAMJ,EAAMyD,KAAKzD,IAGjB,OAFAyD,KAAKzD,IAAM,EAEJA,EAGX,OACI,MAAMA,EAAMyD,KAAK2B,qBACjB,oBAAuBpF,GAM3B,eACI,IAAIsF,EAAM,4BAA+B7B,KAAKzD,KAC9C,OAAe,IAARsF,OAAYxG,EAAYoH,EAAMV,OAAOF,GAMhD,aAAaD,GACT,IAAIK,EAAO,EACN3C,EAAWsC,KACZpC,EAAaoC,EAAMa,GACnBR,EAAOL,EAAKrF,IACZqF,EAAKrF,IAAM,GAEf,4BAA+ByD,KAAKzD,IAAK0F,GAM7C,YAEI,OADU,yBAA4BjC,KAAKzD,OAC5B,EAMnB,UAAUqF,GACN,yBAA4B5B,KAAKzD,IAAKqF,GAO1C,YAAYoC,EAAOC,GACf,IAAIhC,EAAO,EACN3C,EAAW2E,KACZzE,EAAayE,EAAUxB,GACvBR,EAAOgC,EAAS1H,IAChB0H,EAAS1H,IAAM,GAEnB,IAAIsF,EAAM,aAAgBmC,EAAO/B,GACjC,OAAOH,EAAOC,OAAOF,GAQzB,UAAUc,EAAMoB,GACZ,IAAIlC,EAAM,YAAec,EAAMoB,GAC/B,OAAOjC,EAAOC,OAAOF,GAMzB,eACI,IAAIA,EAAM,iBACV,OAAOC,EAAOC,OAAOF,GAMzB,gBACI,IAAIA,EAAM,kBACV,OAAOC,EAAOC,OAAOF,IAItB,SAASqC,EAA2BtC,IArmC3C,SAAoBrG,GAChB,MAAMsG,EAAMvG,EAAUC,IAP1B,SAAoBA,GACZA,EAAM,KACVL,EAAKK,GAAOE,EACZA,EAAYF,IAKZ4I,CAAW5I,GAomCX6I,CAAWxC,GAGR,SAASyC,EAAsBzC,EAAM0C,GAExC,OAAO5H,EADGJ,EAAmBsF,EAAM0C,IAIhC,SAASC,IAEZ,OAAO7H,EADG,IAAIkB,OAIX,SAAS4G,EAA6B5C,EAAM0C,GAC/C,IACIrC,EAAOtD,EADDrD,EAAUgJ,GAAMxG,MACQ,oBAAwB,sBACtD6F,EAAO5F,EACXqB,IAAkBwC,EAAO,EAAI,GAAK+B,EAClCvE,IAAkBwC,EAAO,EAAI,GAAKK,EAG/B,SAASwC,EAA6B7C,EAAM0C,GAC/C,IACII,QAAQC,MAAMrI,EAAmBsF,EAAM0C,IACzC,QACE,kBAAqB1C,EAAM0C,IAI5B,SAASM,IAAgC,OAAOhF,GAAY,WAE/D,OAAOlD,EADGmI,KAAKA,QAEhBC,WAEI,SAASC,EAA+BnD,EAAM0C,EAAMU,GAEvD,OAAOtI,EADGpB,EAAUsG,GAAM9F,QAAQQ,EAAmBgI,EAAMU,KAIxD,SAASC,EAA8BrD,GAE1C,OAAOlF,EADGpB,EAAUsG,GAAMsD,QAIvB,SAASC,EAAgCvD,GAE5C,OAAOlF,EADGpB,EAAUsG,GAAMwD,UAIvB,SAASC,EAAwBzD,GAEpC,YAD8BvG,IAApBC,EAAUsG,GAIjB,SAAS0D,EAAuC1D,GAEnD,OAAOlF,EADGpB,EAAUsG,GAAM2D,iBAIvB,SAASC,EAAuC5D,EAAM0C,GACzDhJ,EAAUsG,GAAM2D,gBAAgBjK,EAAUgJ,IAGvC,SAASmB,EAAsC7D,EAAM0C,EAAMU,GA1+BlE,IAA6BzI,EAAKC,EA2+B9BlB,EAAUsG,GAAM8D,gBA3+BSnJ,EA2+B0B+H,EA3+BrB9H,EA2+B2BwI,EA1+BlD7I,IAAkBM,SAASF,EAAM,EAAGA,EAAM,EAAIC,KA6+BlD,SAASmJ,IAEZ,OAAOjJ,EADGb,GAIP,SAAS+J,EAAyChE,GAErD,OADUtG,EAAUsG,aAAiBiE,OAIlC,SAASC,EAAgClE,GAC5C,IAAIC,EAAMvG,EAAUsG,GAAMmE,SAC1B,OAAOzG,EAAWuC,GAAO,EAAInF,EAAcmF,GAGxC,SAASmE,EAAsCpE,EAAM0C,EAAMU,GAC9D,IAAInD,EAAMvG,EAAUsG,GAAMqE,eAAe3J,EAAmBgI,EAAMU,IAClE,OAAO1F,EAAWuC,GAAO,EAAInF,EAAcmF,GAGxC,SAASqE,EAA6BtE,GACzC8C,QAAQC,MAAMrJ,EAAUsG,IAGrB,SAASuE,EAA2BvE,GACvC8C,QAAQ0B,IAAI9K,EAAUsG,IAGnB,SAASyE,EAA2DzE,GAEvE,OADUtG,EAAUsG,aAAiB0E,yBAIlC,SAASC,GAAsC3E,EAAM0C,GACxDhJ,EAAUsG,GAAM4E,YAAclL,EAAUgJ,GAGrC,SAASmC,GAAoC7E,EAAM0C,GACtDhJ,EAAUsG,GAAM8E,UAAYpL,EAAUgJ,GAGnC,SAASqC,GAAoC/E,EAAM0C,GACtDhJ,EAAUsG,GAAMgF,UAAYtC,EAGzB,SAASuC,GAAiCjF,GAC7CtG,EAAUsG,GAAMkF,YAGb,SAASC,GAA4BnF,GACxCtG,EAAUsG,GAAMxG,OAGb,SAAS4L,GAA8BpF,GAC1CtG,EAAUsG,GAAMqF,SAGb,SAASC,KAA+B,OAAOtH,GAAY,SAAUgC,EAAM0C,EAAMU,EAAMmC,EAAMC,EAAMC,GACtG/L,EAAUsG,GAAM0F,IAAIhD,EAAMU,EAAMmC,EAAMC,EAAMC,KAC7CvC,WAEI,SAASyC,GAAgC3F,EAAM0C,EAAMU,EAAMmC,EAAMC,GACpE9L,EAAUsG,GAAM4F,SAASlD,EAAMU,EAAMmC,EAAMC,GAGxC,SAASK,GAAkC7F,EAAM0C,EAAMU,EAAMmC,EAAMC,GACtE9L,EAAUsG,GAAM8F,WAAWpD,EAAMU,EAAMmC,EAAMC,GAG1C,SAASO,GAAoD/F,GAEhE,OADUtG,EAAUsG,aAAiBgG,kBAIlC,SAASC,GAAgCjG,EAAM0C,GAClDhJ,EAAUsG,GAAMkB,MAAQwB,IAAS,EAG9B,SAASwD,GAAiClG,EAAM0C,GACnDhJ,EAAUsG,GAAMmB,OAASuB,IAAS,EAG/B,SAASyD,KAAsC,OAAOnI,GAAY,SAAUgC,EAAM0C,EAAMU,GAC3F,IAAInD,EAAMvG,EAAUsG,GAAMoG,WAAW1L,EAAmBgI,EAAMU,IAC9D,OAAO1F,EAAWuC,GAAO,EAAInF,EAAcmF,KAC5CiD,WAEI,SAASmD,GAAiCrG,EAAM0C,GAEnD,OAAO5H,EADG,IAAIwL,SAAS5L,EAAmBsF,EAAM0C,KAI7C,SAAS6D,KAAgC,OAAOvI,GAAY,SAAUgC,EAAM0C,GAE/E,OAAO5H,EADGpB,EAAUsG,GAAMrE,KAAKjC,EAAUgJ,OAE1CQ,WAEI,SAASsD,KAAgC,OAAOxI,GAAY,WAE/D,OAAOlD,EADGmI,KAAKA,QAEhBC,WAEI,SAASuD,KAAkC,OAAOzI,GAAY,WAEjE,OAAOlD,EADG4L,OAAOA,UAElBxD,WAEI,SAASyD,KAAsC,OAAO3I,GAAY,WAErE,OAAOlD,EADG8L,WAAWA,cAEtB1D,WAEI,SAAS2D,KAAkC,OAAO7I,GAAY,WAEjE,OAAOlD,EADG,EAAAgM,EAAOC,UAElB7D,WAEI,SAAS8D,GAA8BhH,GAE1C,OAAOlF,EADGpB,EAAUsG,GAAMxF,QAIvB,SAASyM,GAA2BjH,GAEvC,OAAOlF,EADG,IAAIL,WAAWf,EAAUsG,KAIhC,SAASkH,GAA2BlH,EAAM0C,EAAMU,GACnD1J,EAAUsG,GAAMpD,IAAIlD,EAAUgJ,GAAOU,IAAS,GAG3C,SAAS+D,GAA8BnH,GAE1C,OADUtG,EAAUsG,GAAMlG,OAIvB,SAASsN,GAAqCpH,GAEjD,OAAOlF,EADG,IAAIL,WAAWuF,IAAS,IAI/B,SAASqH,GAAgCrH,EAAM0C,EAAMU,GAExD,OAAOtI,EADGpB,EAAUsG,GAAMnF,SAAS6H,IAAS,EAAGU,IAAS,IAIrD,SAASkE,GAA4BtH,GAExC,OAAOlF,EADGpB,EAAUsG,IAIjB,SAASuH,GAAwBvH,EAAM0C,GAC1C,IACIrC,EAAOtD,EADD/B,EAAYtB,EAAUgJ,IACE,oBAAwB,sBACtDX,EAAO5F,EACXqB,IAAkBwC,EAAO,EAAI,GAAK+B,EAClCvE,IAAkBwC,EAAO,EAAI,GAAKK,EAG/B,SAASmH,GAAiBxH,EAAM0C,GACnC,MAAM,IAAI1G,MAAMtB,EAAmBsF,EAAM0C,IAGtC,SAAS+E,KAEZ,OAAO3M,EADG,e,khECn1Cd,IAAI4M,EAAc,EACdC,EAAe,EAEfC,EAAa,EACbC,EAAe,EACfC,EAAiB,GAErB,MAGMC,EAEY,sBAFZA,EAGiB,4BASvB,UAImB5D,SAASE,eAAe,YAA3C,MACM2D,EAAc7D,SAASE,eAAe,YACtC4D,EAAW9D,SAASE,eAAe,UACnC6D,EAAgB/D,SAASE,eAAe,cACxC8D,EAAchE,SAASE,eAAe,aAE3BF,SAASE,eAAe,YAChC+D,QAAUC,EAEnB,IAAIC,EAAa,KACbC,EAAgB,KAChBC,EAqKJ,SAAwBC,EAAKC,EAAY,SAAUC,GAAO,GAClC,MAAjBJ,GACCK,cAAcL,GAGlBP,EAAYpM,UAAY,eAAe8M,IACvCV,EAAYa,UAAYJ,EACxBT,EAAYc,QAAS,EAElBH,IACCJ,EAAgBQ,YAAW,KACvBf,EAAYc,QAAS,IA9MV,OAgCnBE,EAAgBjB,EAEhBkB,EAAO,KACPC,EAAU,KAEVC,EAAS,GAEbd,IAMA,MAAMnG,EAASiC,SAASE,eAAe,eAgBvC,SAASgE,IACLY,EAAO,IAAI,KAAKvB,EAAaC,EAAcC,EAAY,WAAYC,GACnEqB,EAAU,IAAI,KAzEG,IACC,IAwEiC,eACnDD,EAAKG,YAAYF,GACjBD,EAAKI,OAELT,cAAcN,GACdgB,IACAC,IACAJ,EAAS,GACTH,EAAgBjB,EA4IpB,SAASuB,IAEL,OADWL,EAAK7H,gBAEZ,KAAK,WACD6G,EAASY,UAAY,YACrB,MACJ,KAAK,WACDZ,EAASY,UAAY,eAKjC,SAASU,IAEL,OAAON,EAAKO,WACR,UAAK/P,EACD0O,EAAYU,UAAY,GACxB,MACJ,KAAK,WACDV,EAAYU,UAAY,cACxB,MACJ,KAAK,WACDV,EAAYU,UAAY,eA3LpC3G,EAAOuH,iBAAiB,SAAUC,IAC9B,IAAIC,EA8HR,SAAqBzH,EAAQ0H,GACzB,IAAIC,EAAO3H,EAAO4H,wBAClB,MAAO,CACHnM,EAAGiM,EAAIG,QAAUF,EAAKG,KACtBC,EAAGL,EAAIM,QAAUL,EAAKM,KAlIXC,CAAYlI,EAAQwH,IA2BvC,SAA8BW,GAE1B,OAAOrB,GAEH,KAAKjB,EACD,GAAIkB,EAAKqB,mBAAmBD,GAAYjI,OAAS,cAC7C,OAGJ,GAAI6G,EAAKqB,mBAAmBD,GAAYhI,SAAStB,MAAQkI,EAAK7H,eAC1D,OAKJ+H,EAAOvP,KAAKyQ,GACZrB,EAAgBjB,EAChBkB,EAAKsB,aAAaF,GAClBpB,EAAKI,OAEL,MAGJ,KAAKtB,EAID,IAAKoB,EAAO,GAAGqB,GAAGH,GAAa,CAE3B,GAAIpB,EAAKqB,mBAAmBD,GAAYjI,OAAS,WAC7C,OAOJ,GAFA+G,EAAOvP,KAAKyQ,GAES,GAAjBlB,EAAOrP,OAIP,OAHA0O,EAAU,4CAA4CW,EAAOrP,eAC7DgJ,QAAQC,MAAM,4CAA4CoG,EAAOrP,UAOrE,OAFamP,EAAKwB,UAAUtB,EAAO,GAAIA,EAAO,KAG1C,KAAK,aAEGuB,EAAWC,cAA8BlR,IAAnBwP,EAAK2B,YAC3B3B,EAAK4B,UACL3C,EAAcW,UAAY,YAAYI,EAAK6B,gBAAgBC,eAAe,2BAG9E,MACJ,KAAK,uBACDvC,EAAU,6BACV,MACJ,KAAK,qBACDA,EAAU,kCACV,MACJ,KAAK,qBACDA,EAAU,4BACV,MACJ,KAAK,kBACDA,EAAU,0BACV,MACJ,KAAK,iBACDA,EAAU,gEACV,MACJ,KAAK,mBACDA,EAAU,6BACV,MACJ,KAAK,gBACDA,EAAU,iCACV,MACJ,KAAK,kBACDA,EAAU,2BAMtBS,EAAK+B,iBACL/B,EAAKI,OACLF,EAAS,GACTH,EAAgBjB,EAEhB,MACJ,IA3JK,UA4JDjF,QAAQ0B,IAAI,uBAIpB8E,IACAC,IAqEJ,WAEI,OAAON,EAAK2B,WACR,UAAKnR,EACD,MACJ,KAAK,WACD+O,EAAU,aACVF,EAAa2C,aAAY,KACrB5C,MArPI,KAuPR,MACJ,KAAK,WACDG,EAAU,WAAY,WACtBF,EAAa2C,aAAY,KACrB5C,MA3PI,MAyKhB6C,GApHAC,CALW,IAAI,KACXC,KAAKC,MAAO1B,EAASM,EAAI/H,EAAOoJ,aAAgB3D,GAChDyD,KAAKC,MAAO1B,EAAShM,EAAIuE,EAAOqJ,YAAe7D,QAmNvD,MAAM8D,EAAWrH,SAASE,eAAe,SASzCmH,EAASC,SALO,KAEZ/D,EAAcgE,SAASF,EAASxJ,OAChCqG,KAGJmD,EAASxJ,MAAQ,EAEjB,MAAM2J,EAAYxH,SAASE,eAAe,UAU1CsH,EAAUF,SANO,KAEb9D,EAAe+D,SAASC,EAAU3J,OAClC4J,EAAaC,IAAQlE,EAAe,EAAK,EACzCU,KAGJsD,EAAU3J,MAAQ,EAElB,MAAM4J,EAAezH,SAASE,eAAe,aAS7CuH,EAAaH,SALO,KAEhB7D,EAAa8D,SAASE,EAAa5J,OACnCqG,KAGJuD,EAAa5J,MAAQ,EAErB,MAAM8J,EAAmB3H,SAASE,eAAe,mBAajDyH,EAAiBL,SATO,KAEpB5D,EAAe6D,SAASI,EAAiB9J,OACzCiH,EAAK8C,iBAAiBlE,GAEnBA,EAAe,GACdW,EAAU,oFAAqF,YAIvGsD,EAAiB9J,MAAQ,EAEzB,MAAM0I,EAAavG,SAASE,eAAe,eAO3CqG,EAAWe,SAHO,OAMlB,MAAMO,EAAkB7H,SAASE,eAAe,iBAShD2H,EAAgBP,SALQ,KAEpB3D,EAAiB4D,SAASM,EAAgBhK,OAAS,IACnDiH,EAAKgD,mBAAmBnE,IAG5BkE,EAAgBhK,MAAQ","file":"10.bootstrap.js","sourcesContent":["import * as wasm from './draught_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n*/\nexport function init_wasm() {\n    wasm.init_wasm();\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n* Move/Jump, for use in Move\n*/\nexport const MoveType = Object.freeze({ Move:0,\"0\":\"Move\",Jump:1,\"1\":\"Jump\", });\n/**\n* Black/White\n*/\nexport const Team = Object.freeze({ Black:0,\"0\":\"Black\",White:1,\"1\":\"White\", });\n/**\n* Man/King\n*/\nexport const Strength = Object.freeze({ Man:0,\"0\":\"Man\",King:1,\"1\":\"King\", });\n/**\n* Model board square as Empty/Occupied/Unplayable\n*/\nexport const SquareState = Object.freeze({ Empty:0,\"0\":\"Empty\",Occupied:1,\"1\":\"Occupied\",Unplayable:2,\"2\":\"Unplayable\", });\n/**\n* Possible outcomes of trying to move\n*/\nexport const Moveable = Object.freeze({ Allowed:0,\"0\":\"Allowed\",UnoccupiedSrc:1,\"1\":\"UnoccupiedSrc\",OccupiedDest:2,\"2\":\"OccupiedDest\",OutOfBounds:3,\"3\":\"OutOfBounds\",Unplayable:4,\"4\":\"Unplayable\",WrongTeamSrc:5,\"5\":\"WrongTeamSrc\",IllegalTrajectory:6,\"6\":\"IllegalTrajectory\",NoJumpablePiece:7,\"7\":\"NoJumpablePiece\",JumpingSameTeam:8,\"8\":\"JumpingSameTeam\", });\n/**\n* Single state of a checkers board\n*/\nexport class Board {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Board.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_board_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get width() {\n        var ret = wasm.__wbg_get_board_width(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set width(arg0) {\n        wasm.__wbg_set_board_width(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get height() {\n        var ret = wasm.__wbg_get_board_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set height(arg0) {\n        wasm.__wbg_set_board_height(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get current_turn() {\n        var ret = wasm.__wbg_get_board_current_turn(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set current_turn(arg0) {\n        wasm.__wbg_set_board_current_turn(this.ptr, arg0);\n    }\n    /**\n    * Get a copy of a board square by 1D array index\n    * @param {number} idx\n    * @returns {Square}\n    */\n    cell(idx) {\n        var ret = wasm.board_cell(this.ptr, idx);\n        return Square.__wrap(ret);\n    }\n    /**\n    * Get a copy of a board square by 1D array index\n    * @param {number} idx\n    * @param {Square} square\n    */\n    set_cell(idx, square) {\n        _assertClass(square, Square);\n        var ptr0 = square.ptr;\n        square.ptr = 0;\n        wasm.board_set_cell(this.ptr, idx, ptr0);\n    }\n    /**\n    * Get a copy of a board square by 2D [`BrdIdx`] index\n    * @param {BrdIdx} idx\n    * @returns {Square}\n    */\n    grid_cell(idx) {\n        _assertClass(idx, BrdIdx);\n        var ptr0 = idx.ptr;\n        idx.ptr = 0;\n        var ret = wasm.board_grid_cell(this.ptr, ptr0);\n        return Square.__wrap(ret);\n    }\n    /**\n    * Transform a 2D row/column board index into a single 1D index for use with [`Board::cells`]\n    * @param {number} row\n    * @param {number} col\n    * @returns {number}\n    */\n    cell_index(row, col) {\n        var ret = wasm.board_cell_index(this.ptr, row, col);\n        return ret >>> 0;\n    }\n    /**\n    * Similar to [`Board::cell_index`] but with a [`BrdIdx`] instead of separate indices. Transform a 2D row/column board index into a single 1D index for use with [`Board::cells`]\n    * @param {BrdIdx} idx\n    * @returns {number}\n    */\n    cell_idx(idx) {\n        _assertClass(idx, BrdIdx);\n        var ptr0 = idx.ptr;\n        idx.ptr = 0;\n        var ret = wasm.board_cell_idx(this.ptr, ptr0);\n        return ret >>> 0;\n    }\n    /**\n    * Transform a 1D array index (for [`Board::cells`]) into a 2D game board index (by row/col)\n    * @param {number} idx\n    * @returns {BrdIdx}\n    */\n    board_index(idx) {\n        var ret = wasm.board_board_index(this.ptr, idx);\n        return BrdIdx.__wrap(ret);\n    }\n    /**\n    * Check whether a move given by source and destination indices is legal\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    * @returns {number}\n    */\n    can_move(from, to) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        var ret = wasm.board_can_move(this.ptr, ptr0, ptr1);\n        return ret >>> 0;\n    }\n    /**\n    * Check that given move trajectory is valid for a man piece\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    * @param {Piece} from_square_occupant\n    * @returns {number}\n    */\n    validate_man_move(from, to, from_square_occupant) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        _assertClass(from_square_occupant, Piece);\n        var ptr2 = from_square_occupant.ptr;\n        from_square_occupant.ptr = 0;\n        var ret = wasm.board_validate_man_move(this.ptr, ptr0, ptr1, ptr2);\n        return ret >>> 0;\n    }\n    /**\n    * Check that given move trajectory is valid for a king piece\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    * @param {Piece} from_square_occupant\n    * @returns {number}\n    */\n    validate_king_move(from, to, from_square_occupant) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        _assertClass(from_square_occupant, Piece);\n        var ptr2 = from_square_occupant.ptr;\n        from_square_occupant.ptr = 0;\n        var ret = wasm.board_validate_king_move(this.ptr, ptr0, ptr1, ptr2);\n        return ret >>> 0;\n    }\n    /**\n    * Get cell index of jumpee square given from and to locations\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    * @returns {number}\n    */\n    jumpee_idx(from, to) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        var ret = wasm.board_jumpee_idx(this.ptr, ptr0, ptr1);\n        return ret >>> 0;\n    }\n    /**\n    * Get a pointer to the backing array of board squares, [`Board::cells`]\n    * @returns {number}\n    */\n    cells() {\n        var ret = wasm.board_cells(this.ptr);\n        return ret;\n    }\n    /**\n    * Get the number of board squares\n    * @returns {number}\n    */\n    num_cells() {\n        var ret = wasm.board_num_cells(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get the number of remaining pieces\n    * @returns {number}\n    */\n    num_pieces() {\n        var ret = wasm.board_num_pieces(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get the number of remaining pieces for a player\n    * @param {number} team\n    * @returns {number}\n    */\n    num_player(team) {\n        var ret = wasm.board_num_player(this.ptr, team);\n        return ret >>> 0;\n    }\n    /**\n    * Get the score value, Black - White pieces\n    * @returns {number}\n    */\n    score() {\n        var ret = wasm.board_score(this.ptr);\n        return ret;\n    }\n    /**\n    * Get the state of a board square by 1D array index\n    * @param {number} idx\n    * @returns {number}\n    */\n    cell_state(idx) {\n        var ret = wasm.board_cell_state(this.ptr, idx);\n        return ret >>> 0;\n    }\n    /**\n    * Get new board derived from current with given move applied\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    * @returns {Board}\n    */\n    apply_move(from, to) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        var ret = wasm.board_apply_move(this.ptr, ptr0, ptr1);\n        return Board.__wrap(ret);\n    }\n    /**\n    * Get new board derived from current with given jump applied\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    * @returns {Board}\n    */\n    apply_jump(from, to) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        var ret = wasm.board_apply_jump(this.ptr, ptr0, ptr1);\n        return Board.__wrap(ret);\n    }\n    /**\n    * Get row index for current team, top row for black, bottom row for white\n    * @returns {number}\n    */\n    king_row_idx() {\n        var ret = wasm.board_king_row_idx(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Unwrap the jumpee piece from the square and [`Board::check_jumpee_team`] with [`Moveable`] response\n    * @param {Square} jumpee\n    * @param {Piece} from_occ\n    * @returns {number}\n    */\n    static validate_jumpee(jumpee, from_occ) {\n        _assertClass(jumpee, Square);\n        var ptr0 = jumpee.ptr;\n        jumpee.ptr = 0;\n        _assertClass(from_occ, Piece);\n        var ptr1 = from_occ.ptr;\n        from_occ.ptr = 0;\n        var ret = wasm.board_validate_jumpee(ptr0, ptr1);\n        return ret >>> 0;\n    }\n    /**\n    * Check that the source piece and the jumpee are of opposing teams\n    * @param {Piece} from\n    * @param {Piece} jumpee\n    * @returns {boolean}\n    */\n    static check_jumpee_team(from, jumpee) {\n        _assertClass(from, Piece);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(jumpee, Piece);\n        var ptr1 = jumpee.ptr;\n        jumpee.ptr = 0;\n        var ret = wasm.board_check_jumpee_team(ptr0, ptr1);\n        return ret !== 0;\n    }\n    /**\n    * Initialise a game board without game pieces\n    * @param {number} width\n    * @param {number} height\n    * @param {number} current_turn\n    */\n    constructor(width, height, current_turn) {\n        var ret = wasm.board_new(width, height, current_turn);\n        return Board.__wrap(ret);\n    }\n    /**\n    * Reset the given board to a starting layout with 3 rows of opposing pieces\n    * @param {Board} board\n    * @param {number} piece_rows\n    * @returns {Board}\n    */\n    static init_game(board, piece_rows) {\n        _assertClass(board, Board);\n        var ptr0 = board.ptr;\n        board.ptr = 0;\n        var ret = wasm.board_init_game(ptr0, piece_rows);\n        return Board.__wrap(ret);\n    }\n}\n/**\n* Rank 2 tensor index to identify a board square by row and column\n*/\nexport class BrdIdx {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BrdIdx.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_brdidx_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get row() {\n        var ret = wasm.__wbg_get_brdidx_row(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set row(arg0) {\n        wasm.__wbg_set_brdidx_row(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get col() {\n        var ret = wasm.__wbg_get_brdidx_col(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set col(arg0) {\n        wasm.__wbg_set_brdidx_col(this.ptr, arg0);\n    }\n    /**\n    * @param {number} row\n    * @param {number} col\n    */\n    constructor(row, col) {\n        var ret = wasm.brdidx_from(row, col);\n        return BrdIdx.__wrap(ret);\n    }\n    /**\n    * @param {BrdIdx} other\n    * @returns {boolean}\n    */\n    eq(other) {\n        _assertClass(other, BrdIdx);\n        var ret = wasm.brdidx_eq(this.ptr, other.ptr);\n        return ret !== 0;\n    }\n}\n/**\n* Root-level structure for managing the game as a collection of board states\n*/\nexport class Game {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Game.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_game_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get last_node_count() {\n        var ret = wasm.__wbg_get_game_last_node_count(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set last_node_count(arg0) {\n        wasm.__wbg_set_game_last_node_count(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get perfect_chance() {\n        var ret = wasm.__wbg_get_game_perfect_chance(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set perfect_chance(arg0) {\n        wasm.__wbg_set_game_perfect_chance(this.ptr, arg0);\n    }\n    /**\n    * Get pointer to current board's squares\n    * @returns {number}\n    */\n    current_board_cells() {\n        var ret = wasm.game_current_board_cells(this.ptr);\n        return ret;\n    }\n    /**\n    * Get pointer to current board's squares\n    * @returns {number}\n    */\n    current_board_len() {\n        var ret = wasm.game_current_board_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Current turn's team\n    * @returns {number}\n    */\n    current_turn() {\n        var ret = wasm.game_current_turn(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Current board's score\n    * @returns {number}\n    */\n    score() {\n        var ret = wasm.game_score(this.ptr);\n        return ret;\n    }\n    /**\n    * Get currently winning player\n    * @returns {number | undefined}\n    */\n    winning() {\n        var ret = wasm.game_winning(this.ptr);\n        return ret === 2 ? undefined : ret;\n    }\n    /**\n    * Check if a player has won\n    * @returns {number | undefined}\n    */\n    has_won() {\n        var ret = wasm.game_has_won(this.ptr);\n        return ret === 2 ? undefined : ret;\n    }\n    /**\n    * Get square on current board for given index\n    * @param {BrdIdx} idx\n    * @returns {Square}\n    */\n    current_cell_state(idx) {\n        _assertClass(idx, BrdIdx);\n        var ret = wasm.game_current_cell_state(this.ptr, idx.ptr);\n        return Square.__wrap(ret);\n    }\n    /**\n    * Set tree depth for AI to search to\n    * @param {number} search_depth\n    */\n    set_search_depth(search_depth) {\n        wasm.game_set_search_depth(this.ptr, search_depth);\n    }\n    /**\n    * Set given index as selected piece\n    * TODO: Check whether valid square?\n    * @param {BrdIdx} idx\n    */\n    set_selected(idx) {\n        _assertClass(idx, BrdIdx);\n        wasm.game_set_selected(this.ptr, idx.ptr);\n    }\n    /**\n    * Set proportion of perfect moves from AI\n    * @param {number} new_chance\n    */\n    set_perfect_chance(new_chance) {\n        wasm.game_set_perfect_chance(this.ptr, new_chance);\n    }\n    /**\n    * Clear currently selected piece\n    */\n    clear_selected() {\n        wasm.game_clear_selected(this.ptr);\n    }\n    /**\n    * Attempt to make a move given a source and destination index\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    * @returns {number}\n    */\n    make_move(from, to) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        var ret = wasm.game_make_move(this.ptr, ptr0, ptr1);\n        return ret >>> 0;\n    }\n    /**\n    * Update board state with given move and push new board into current state\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    */\n    execute_move(from, to) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        wasm.game_execute_move(this.ptr, ptr0, ptr1);\n    }\n    /**\n    * Update board state with given jump move and push new board into current state\n    * @param {BrdIdx} from\n    * @param {BrdIdx} to\n    */\n    execute_jump(from, to) {\n        _assertClass(from, BrdIdx);\n        var ptr0 = from.ptr;\n        from.ptr = 0;\n        _assertClass(to, BrdIdx);\n        var ptr1 = to.ptr;\n        to.ptr = 0;\n        wasm.game_execute_jump(this.ptr, ptr0, ptr1);\n    }\n    /**\n    * Push current board into the previous turns and set given board to current\n    * @param {Board} board\n    */\n    push_new_board(board) {\n        _assertClass(board, Board);\n        var ptr0 = board.ptr;\n        board.ptr = 0;\n        wasm.game_push_new_board(this.ptr, ptr0);\n    }\n    /**\n    * Set current board to given\n    * @param {Board} board\n    */\n    set_current(board) {\n        _assertClass(board, Board);\n        var ptr0 = board.ptr;\n        board.ptr = 0;\n        wasm.game_set_current(this.ptr, ptr0);\n    }\n    /**\n    * Get new game without board renderer\n    * @param {number} width\n    * @param {number} height\n    * @param {number} piece_rows\n    * @param {number} first_turn\n    * @param {number} search_depth\n    */\n    constructor(width, height, piece_rows, first_turn, search_depth) {\n        var ret = wasm.game_new(width, height, piece_rows, first_turn, search_depth);\n        return Game.__wrap(ret);\n    }\n    /**\n    * Get a new game with canvas ID and dimensions\n    * @param {number} width\n    * @param {number} height\n    * @param {number} piece_rows\n    * @param {number} first_turn\n    * @param {number} search_depth\n    * @param {string} canvas_id\n    * @param {number} canvas_width\n    * @param {number} canvas_height\n    * @returns {Game}\n    */\n    static new_with_canvas(width, height, piece_rows, first_turn, search_depth, canvas_id, canvas_width, canvas_height) {\n        var ptr0 = passStringToWasm0(canvas_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.game_new_with_canvas(width, height, piece_rows, first_turn, search_depth, ptr0, len0, canvas_width, canvas_height);\n        return Game.__wrap(ret);\n    }\n    /**\n    * Set painter for rendering boards\n    * @param {Painter} value\n    */\n    set_painter(value) {\n        _assertClass(value, Painter);\n        var ptr0 = value.ptr;\n        value.ptr = 0;\n        wasm.game_set_painter(this.ptr, ptr0);\n    }\n    /**\n    * Draw current board using painter if exists\n    */\n    draw() {\n        wasm.game_draw(this.ptr);\n    }\n    /**\n    * Create computer, get move from current board and update current board\n    */\n    ai_move() {\n        wasm.game_ai_move(this.ptr);\n    }\n}\n/**\n* Used to paint boards onto HTML canvases\n*/\nexport class Painter {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Painter.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_painter_free(ptr);\n    }\n    /**\n    * Default constructor which queries for canvas by ID\n    * @param {number} width\n    * @param {number} height\n    * @param {string} canvas_id\n    */\n    constructor(width, height, canvas_id) {\n        var ptr0 = passStringToWasm0(canvas_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.painter_new(width, height, ptr0, len0);\n        return Painter.__wrap(ret);\n    }\n    /**\n    * Constructor with given canvas element\n    * @param {number} width\n    * @param {number} height\n    * @param {HTMLCanvasElement} canvas\n    * @returns {Painter}\n    */\n    static new_with_canvas(width, height, canvas) {\n        var ret = wasm.painter_new_with_canvas(width, height, addHeapObject(canvas));\n        return Painter.__wrap(ret);\n    }\n    /**\n    * Set new square outline colour value\n    * @param {any} value\n    */\n    set_square_outline(value) {\n        wasm.painter_set_square_outline(this.ptr, addHeapObject(value));\n    }\n    /**\n    * Set new line width for outlining squares\n    * @param {number} value\n    */\n    set_outline_width(value) {\n        wasm.painter_set_outline_width(this.ptr, value);\n    }\n    /**\n    * Set whether squares are outlined\n    * @param {boolean} value\n    */\n    set_draw_outline(value) {\n        wasm.painter_set_draw_outline(this.ptr, value);\n    }\n    /**\n    * Reset the canvas dimensions to the given width and height\n    */\n    reset_dimensions() {\n        wasm.painter_reset_dimensions(this.ptr);\n    }\n    /**\n    * Check whether given canvas dimensions divide evenly by given board dimenions\n    * @param {Board} board\n    * @returns {boolean}\n    */\n    validate_board_dim(board) {\n        _assertClass(board, Board);\n        var ret = wasm.painter_validate_board_dim(this.ptr, board.ptr);\n        return ret !== 0;\n    }\n    /**\n    * Draw a board onto the canvas\n    * @param {Board} board\n    */\n    draw(board) {\n        _assertClass(board, Board);\n        wasm.painter_draw(this.ptr, board.ptr);\n    }\n}\n/**\n* Game piece given by its team and strength (normal or kinged)\n*/\nexport class Piece {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Piece.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_piece_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get team() {\n        var ret = wasm.__wbg_get_piece_team(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set team(arg0) {\n        wasm.__wbg_set_piece_team(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get strength() {\n        var ret = wasm.__wbg_get_piece_strength(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set strength(arg0) {\n        wasm.__wbg_set_piece_strength(this.ptr, arg0);\n    }\n    /**\n    * @param {number} team\n    * @param {number} strength\n    */\n    constructor(team, strength) {\n        var ret = wasm.piece_new(team, strength);\n        return Piece.__wrap(ret);\n    }\n}\n/**\n* Board squares given by a state and a possible occupying game piece\n*/\nexport class Square {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Square.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_square_free(ptr);\n    }\n    /**\n    * Game piece if square is occupied\n    * @returns {Piece | undefined}\n    */\n    get occupant() {\n        var ret = wasm.__wbg_get_square_occupant(this.ptr);\n        return ret === 0 ? undefined : Piece.__wrap(ret);\n    }\n    /**\n    * Game piece if square is occupied\n    * @param {Piece | undefined} arg0\n    */\n    set occupant(arg0) {\n        let ptr0 = 0;\n        if (!isLikeNone(arg0)) {\n            _assertClass(arg0, Piece);\n            ptr0 = arg0.ptr;\n            arg0.ptr = 0;\n        }\n        wasm.__wbg_set_square_occupant(this.ptr, ptr0);\n    }\n    /**\n    * Description of whether the square is occupied or an unplayable, i.e. off-lattice square\n    * @returns {number}\n    */\n    get state() {\n        var ret = wasm.__wbg_get_square_state(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Description of whether the square is occupied or an unplayable, i.e. off-lattice square\n    * @param {number} arg0\n    */\n    set state(arg0) {\n        wasm.__wbg_set_square_state(this.ptr, arg0);\n    }\n    /**\n    * Standard constructor function to form square from state and occupant\n    * @param {number} state\n    * @param {Piece | undefined} occupant\n    */\n    constructor(state, occupant) {\n        let ptr0 = 0;\n        if (!isLikeNone(occupant)) {\n            _assertClass(occupant, Piece);\n            ptr0 = occupant.ptr;\n            occupant.ptr = 0;\n        }\n        var ret = wasm.square_new(state, ptr0);\n        return Square.__wrap(ret);\n    }\n    /**\n    * Helper function for a well-formed piece square by team and strength\n    * @param {number} team\n    * @param {number} strength\n    * @returns {Square}\n    */\n    static pc(team, strength) {\n        var ret = wasm.square_pc(team, strength);\n        return Square.__wrap(ret);\n    }\n    /**\n    * Helper function for a well-formed empty square\n    * @returns {Square}\n    */\n    static empty() {\n        var ret = wasm.square_empty();\n        return Square.__wrap(ret);\n    }\n    /**\n    * Helper function for a well-formed unplayable square\n    * @returns {Square}\n    */\n    static unplay() {\n        var ret = wasm.square_unplay();\n        return Square.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    var ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_59cb74e423758ede() {\n    var ret = new Error();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_stack_558ba5917b466edd(arg0, arg1) {\n    var ret = getObject(arg1).stack;\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbg_error_4bb6c2a97407129a(arg0, arg1) {\n    try {\n        console.error(getStringFromWasm0(arg0, arg1));\n    } finally {\n        wasm.__wbindgen_free(arg0, arg1);\n    }\n};\n\nexport function __wbg_self_86b4b13392c7af56() { return handleError(function () {\n    var ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_require_f5521a5b85ad2542(arg0, arg1, arg2) {\n    var ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_crypto_b8c92eaac23d0d80(arg0) {\n    var ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_msCrypto_9ad6677321a08dd8(arg0) {\n    var ret = getObject(arg0).msCrypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_undefined(arg0) {\n    var ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nexport function __wbg_getRandomValues_dd27e6b0652b3236(arg0) {\n    var ret = getObject(arg0).getRandomValues;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_getRandomValues_e57c9b75ddead065(arg0, arg1) {\n    getObject(arg0).getRandomValues(getObject(arg1));\n};\n\nexport function __wbg_randomFillSync_d2ba53160aec6aba(arg0, arg1, arg2) {\n    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n};\n\nexport function __wbg_static_accessor_MODULE_452b4680e8614c81() {\n    var ret = module;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_instanceof_Window_11e25482011fc506(arg0) {\n    var ret = getObject(arg0) instanceof Window;\n    return ret;\n};\n\nexport function __wbg_document_5aff8cd83ef968f5(arg0) {\n    var ret = getObject(arg0).document;\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n};\n\nexport function __wbg_getElementById_b180ea4ada06a837(arg0, arg1, arg2) {\n    var ret = getObject(arg0).getElementById(getStringFromWasm0(arg1, arg2));\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n};\n\nexport function __wbg_error_d95afd6217cfd219(arg0) {\n    console.error(getObject(arg0));\n};\n\nexport function __wbg_log_9a99fb1af846153b(arg0) {\n    console.log(getObject(arg0));\n};\n\nexport function __wbg_instanceof_CanvasRenderingContext2d_779e79c4121aa91b(arg0) {\n    var ret = getObject(arg0) instanceof CanvasRenderingContext2D;\n    return ret;\n};\n\nexport function __wbg_setstrokeStyle_2939ee453716e462(arg0, arg1) {\n    getObject(arg0).strokeStyle = getObject(arg1);\n};\n\nexport function __wbg_setfillStyle_af790b5baf4d3210(arg0, arg1) {\n    getObject(arg0).fillStyle = getObject(arg1);\n};\n\nexport function __wbg_setlineWidth_3e6b1837ae38d099(arg0, arg1) {\n    getObject(arg0).lineWidth = arg1;\n};\n\nexport function __wbg_beginPath_2378575e37027ad3(arg0) {\n    getObject(arg0).beginPath();\n};\n\nexport function __wbg_fill_558339447ed6ad43(arg0) {\n    getObject(arg0).fill();\n};\n\nexport function __wbg_stroke_c1e0313c58997dcf(arg0) {\n    getObject(arg0).stroke();\n};\n\nexport function __wbg_arc_fffd87d9113dce32() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5) {\n    getObject(arg0).arc(arg1, arg2, arg3, arg4, arg5);\n}, arguments) };\n\nexport function __wbg_fillRect_46ffc8d2cef7e298(arg0, arg1, arg2, arg3, arg4) {\n    getObject(arg0).fillRect(arg1, arg2, arg3, arg4);\n};\n\nexport function __wbg_strokeRect_7ea34fad8a7f0fe2(arg0, arg1, arg2, arg3, arg4) {\n    getObject(arg0).strokeRect(arg1, arg2, arg3, arg4);\n};\n\nexport function __wbg_instanceof_HtmlCanvasElement_fd3cbbe3906d7792(arg0) {\n    var ret = getObject(arg0) instanceof HTMLCanvasElement;\n    return ret;\n};\n\nexport function __wbg_setwidth_f3c88eb520ba8d47(arg0, arg1) {\n    getObject(arg0).width = arg1 >>> 0;\n};\n\nexport function __wbg_setheight_5a1abba41e35c42a(arg0, arg1) {\n    getObject(arg0).height = arg1 >>> 0;\n};\n\nexport function __wbg_getContext_813df131fcbd6e91() { return handleError(function (arg0, arg1, arg2) {\n    var ret = getObject(arg0).getContext(getStringFromWasm0(arg1, arg2));\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_newnoargs_9fdd8f3961dd1bee(arg0, arg1) {\n    var ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_ba36642bd901572b() { return handleError(function (arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_self_bb69a836a72ec6e9() { return handleError(function () {\n    var ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_window_3304fc4b414c9693() { return handleError(function () {\n    var ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_globalThis_e0d21cabc6630763() { return handleError(function () {\n    var ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_global_8463719227271676() { return handleError(function () {\n    var ret = global.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_buffer_9e184d6f785de5ed(arg0) {\n    var ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_e8101319e4cf95fc(arg0) {\n    var ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_e8ae7b27314e8b98(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_2d56cb37075fcfb1(arg0) {\n    var ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_a8d1dbcbe703a5c6(arg0) {\n    var ret = new Uint8Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_subarray_901ede8318da52a6(arg0, arg1, arg2) {\n    var ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_object_clone_ref(arg0) {\n    var ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_debug_string(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    var ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n","import { Game, Board, BrdIdx, Painter, Team, init_wasm, Moveable, SquareState, Square } from \"draught\";\n// import { memory } from \"draught/draught_bg.wasm\";\n\n///////////////////\n//    CONSTS\n///////////////////\n\nconst CANVAS_WIDTH = 720;\nconst CANVAS_HEIGHT = 720;\n\nvar BOARD_WIDTH = 8;\nvar BOARD_HEIGHT = 8;\n\nvar PIECE_ROWS = 3;\nvar SEARCH_DEPTH = 4;\nvar PERFECT_CHANCE = 0.5;\n\nconst STATUS_TIMEOUT = 3000;\nconst WON_TIMEOUT = 3000;\n\nconst GameState = {\n    HUMAN_TURN: {\n        THINKING: \"human_turn.thinking\",\n        FROM_SELECTED: \"human_turn.from_selected\"\n    },\n    AI_TURN: \"ai_turn\"\n}\n\n//////////////////\n//  GAME STUFF\n//////////////////\n\ninit_wasm();\n\n// let board = new Board(BOARD_WIDTH, BOARD_HEIGHT, Team.Black);\n\nconst statusText = document.getElementById(\"status-p\");\nconst statusAlert = document.getElementById(\"status-d\");\nconst teamText = document.getElementById(\"team-p\");\nconst nodeCountText = document.getElementById(\"node-count\");\nconst winningText = document.getElementById(\"winning-p\");\n\nconst startBtn = document.getElementById(\"startBtn\");\nstartBtn.onclick = start_game;\n\nlet wonTimeout = null;\nlet statusTimeout = null;\nlet setStatus = setStatusAlert;\n\nlet current_state = GameState.HUMAN_TURN.THINKING;\n\nlet game = null;\nlet painter = null;\n\nlet clicks = [];\n\nstart_game();\n\n/////////////////\n//   CANVAS\n/////////////////\n\nconst canvas = document.getElementById(\"game-canvas\");\ncanvas.addEventListener(\"click\", (event) => {\n    var mousepos = getMousePos(canvas, event);\n    // console.log(mousepos);\n    var cell = new BrdIdx(\n        Math.floor((mousepos.y / canvas.clientHeight) * BOARD_HEIGHT),\n        Math.floor((mousepos.x / canvas.clientWidth) * BOARD_WIDTH),\n    );\n    // console.log(cell);\n    process_canvas_click(cell);\n});\n\n////////////////\n//   FUNCS\n////////////////\n\nfunction start_game() {\n    game = new Game(BOARD_WIDTH, BOARD_HEIGHT, PIECE_ROWS, Team.Black, SEARCH_DEPTH);\n    painter = new Painter(CANVAS_WIDTH, CANVAS_HEIGHT, \"game-canvas\");\n    game.set_painter(painter);\n    game.draw();\n\n    clearInterval(wonTimeout);\n    updateTeamText();\n    updateWinningText();\n    clicks = [];\n    current_state = GameState.HUMAN_TURN.THINKING;\n}\n\nfunction process_canvas_click(cell_coord) {\n\n    switch(current_state) {\n        // first click of a move\n        case GameState.HUMAN_TURN.THINKING:\n            if (game.current_cell_state(cell_coord).state != SquareState.Occupied ) {\n                return;\n            }\n\n            if (game.current_cell_state(cell_coord).occupant.team != game.current_turn() ) {\n                return;\n            }\n\n            // console.log(\"Your turn, first piece picked\");\n\n            clicks.push(cell_coord);\n            current_state = GameState.HUMAN_TURN.FROM_SELECTED;\n            game.set_selected(cell_coord);\n            game.draw();\n            \n            break;\n            \n        // second click of a move\n        case GameState.HUMAN_TURN.FROM_SELECTED:\n\n            // second click is different to first, process as move\n            // otherwise, will skip straight to clean up (clear selected and clicks) \n            if (!clicks[0].eq(cell_coord)) {\n\n                if (game.current_cell_state(cell_coord).state != SquareState.Empty ) {\n                    return;\n                }\n    \n                // console.log(\"Your turn, first piece already picked, picking second\");\n    \n                clicks.push(cell_coord);\n    \n                if (clicks.length != 2) {\n                    setStatus(`Error: wrong number of clicks to process ${clicks.length}`);\n                    console.error(`Error: wrong number of clicks to process ${clicks.length}`);\n    \n                    return;\n                }\n\n                let status = game.make_move(clicks[0], clicks[1]);\n\n                switch(status) {\n                    case Moveable.Allowed:\n\n                        if (aiCheckBox.checked && game.has_won() === undefined) {\n                            game.ai_move();\n                            nodeCountText.innerText = `searched ${game.last_node_count.toLocaleString(\"en-GB\")} possible moves`;\n                        }\n\n                        break;\n                    case Moveable.IllegalTrajectory:\n                        setStatus(\"You can't move like that!\");\n                        break;\n                    case Moveable.JumpingSameTeam:\n                        setStatus(\"You can't jump your own piece!\");\n                        break;\n                    case Moveable.NoJumpablePiece:\n                        setStatus(\"There's nothing to jump!\");\n                        break;\n                    case Moveable.OccupiedDest:\n                        setStatus(\"There's a piece there!\");\n                        break;\n                    case Moveable.OutOfBounds:\n                        setStatus(\"That square's not on the board! (how have you managed that?)\");\n                        break;\n                    case Moveable.UnoccupiedSrc:\n                        setStatus(\"There's no piece to move!\");\n                        break;\n                    case Moveable.Unplayable:\n                        setStatus(\"That's not a playable square!\");\n                        break;\n                    case Moveable.WrongTeamSrc:\n                        setStatus(\"That's not your piece!\");\n                        break;\n                }\n                \n            }\n\n            game.clear_selected();\n            game.draw();\n            clicks = [];\n            current_state = GameState.HUMAN_TURN.THINKING;\n            \n            break;\n        case GameState.AI_TURN:\n            console.log(\"It's the AI's turn!\");\n            break;\n    }\n\n    updateTeamText();\n    updateWinningText();\n    checkWon();\n}\n\nfunction getMousePos(canvas, evt) {\n    var rect = canvas.getBoundingClientRect();\n    return {\n        x: evt.clientX - rect.left,\n        y: evt.clientY - rect.top\n    };\n}\n\nfunction setStatusText(txt, hide = true) {\n    if(statusTimeout != null) {\n        clearInterval(statusTimeout);\n    }\n\n    statusText.innerText = txt;\n\n    if(hide) {\n        statusTimeout = setTimeout(() => {\n            statusText.innerText = \"\";\n        }, STATUS_TIMEOUT);\n    }\n}\n\nfunction setStatusAlert(txt, alertType = \"danger\", hide = true) {\n    if(statusTimeout != null) {\n        clearInterval(statusTimeout);\n    }\n\n    statusAlert.className = `alert alert-${alertType}`;\n    statusAlert.innerText = txt;\n    statusAlert.hidden = false;\n\n    if(hide) {\n        statusTimeout = setTimeout(() => {\n            statusAlert.hidden = true;\n        }, STATUS_TIMEOUT);\n    }\n}\n\nfunction updateTeamText(){\n    let team = game.current_turn();\n    switch(team) {\n        case Team.White:\n            teamText.innerText = \" White \";\n            break;\n        case Team.Black:\n            teamText.innerText = \" Black \";\n            break;\n    }\n}\n\nfunction updateWinningText(){\n    \n    switch(game.winning()) {\n        case undefined:\n            winningText.innerText = \"\";\n            break;\n        case Team.White:\n            winningText.innerText = \" White \";\n            break;\n        case Team.Black:\n            winningText.innerText = \" Black \";\n            break;\n    }\n}\n\nfunction checkWon() {\n\n    switch(game.has_won()) {\n        case undefined:\n            break;\n        case Team.White:\n            setStatus(\"You Lost!\");\n            wonTimeout = setInterval(() => {\n                start_game();\n            }, WON_TIMEOUT);\n            break;\n        case Team.Black:\n            setStatus(\"You Won!\", \"success\");\n            wonTimeout = setInterval(() => {\n                start_game();\n            }, WON_TIMEOUT);\n            break;\n    }\n}\n\n////////////////\n//     UI\n////////////////\n\nconst widthBox = document.getElementById(\"width\");\n/**\n * Handler for width input box change, start a new game\n */\nconst onWidth = () => {\n\n    BOARD_WIDTH = parseInt(widthBox.value);\n    start_game();\n}\nwidthBox.onchange = onWidth;\nwidthBox.value = 8;\n\nconst heightBox = document.getElementById(\"height\");\n/**\n * Handler for height input box change, start a new game\n */\nconst onHeight = () => {\n\n    BOARD_HEIGHT = parseInt(heightBox.value);\n    pieceRowsBox.max =  (BOARD_HEIGHT / 2) - 1;\n    start_game();\n}\nheightBox.onchange = onHeight;\nheightBox.value = 8;\n\nconst pieceRowsBox = document.getElementById(\"play_rows\");\n/**\n * Handler for piece rows input box change, start a new game\n */\nconst onPieceRows = () => {\n\n    PIECE_ROWS = parseInt(pieceRowsBox.value);\n    start_game();\n}\npieceRowsBox.onchange = onPieceRows;\npieceRowsBox.value = 3;\n\nconst aiSearchDepthBox = document.getElementById(\"ai_search_depth\");\n/**\n * Handler for AI search depth input box change, start a new game\n */\nconst onAISearchDepth = () => {\n\n    SEARCH_DEPTH = parseInt(aiSearchDepthBox.value);\n    game.set_search_depth(SEARCH_DEPTH);\n\n    if(SEARCH_DEPTH > 4) {\n        setStatus(\"This increases thinking time exponentially, be careful (probably don't go past 6)\", \"warning\");\n    }\n}\naiSearchDepthBox.onchange = onAISearchDepth;\naiSearchDepthBox.value = 4;\n\nconst aiCheckBox = document.getElementById(\"ai-checkbox\");\n/**\n * Handler for height input box change, get a new universe of given size\n */\nconst onAICheck = () => {\n    \n}\naiCheckBox.onchange = onAICheck;\n// aiCheckBox.checked = true;\n\nconst aiPerfectChance = document.getElementById(\"ai_difficulty\");\n/**\n * Handler for piece rows input box change, start a new game\n */\nconst onPerfectChance = () => {\n\n    PERFECT_CHANCE = parseInt(aiPerfectChance.value) / 100;\n    game.set_perfect_chance(PERFECT_CHANCE);\n}\naiPerfectChance.onchange = onPerfectChance;\naiPerfectChance.value = 50;"],"sourceRoot":""}